---
author: "Lingyu Zhang"
author_link: "https://jarviszl.github.io/"
title: "语法分析"
date: 2020-02-27T10:06:04+08:00
lastmod: 2020-02-27T10:06:04+08:00
draft: false
description: ""
show_in_homepage: true
description_as_summary: false
license: ""

tags: [编译原理]
categories: [编译原理]

featured_image: ""
featured_image_preview: ""

comment: true
toc: false
auto_collapse_toc: true
math: true
---

# 语法分析器
- 基本作用
  - 从词法分析器获得词法单元序列，确认该序列是否可以由语言的文法生成
  - 对于语法错误的程序，报告错误信息
  - 对于语法正确的程序，生成**语法分析树(语法树)**
  ![语法分析器](/images/documents/编译原理/语法分析器.png)
- 分类
  - 自顶向下语法分析器(用于处理LL文法)
    - 从语法分析树的**根部**开始构造语法分析树
  - 自底向上语法分析器(用于处理LR文法)
    - 从语法分析树的叶子开始构造语法分析树
  - 两个第一个L都表示**从左到右，逐个扫描**词法单元

# 上下文无关文法(CFG)

## 组成部分
- **终结符号**：组成串的基本符号(**词法单元**名字)
- **非终结符号**：表示串的集合的语法**变量**
  - 在程序设计语言中通常对应于某个程序构造如$\textit{stmt}$
- **开始符号**：某个被指定的**非终结符号**
  - 对应的串的集合就是文法的语言
- **产生式**：描述将终结符号和非终结符号组成串的方法
  - 形式：头(左)部$\rightarrow$ 体(右)部
  - 头部是一个非终结符号，右边是一个符号串
  - 例如:$\textit{expression} \rightarrow \textit{expression} + \textit{term}$(加法表达式)

## 例子
- 简单算术表达式文法
  - 终结符号: $id,+,-,*,/,(,)$
  - 非终结符号：$\textit{expression}, \textit{term}, \textit{factor}$
  - 开始符号：$\textit{expression}$
  - 产生式集合
    - $\textit{expression} \rightarrow \textit{expression} + \textit{term}$
    - $\textit{expression} \rightarrow \textit{expression} - \textit{term}$
    - $\textit{expression} \rightarrow \textit{term}$
    - $\textit{term} \rightarrow \textit{term} * \textit{factor}$
    - $\textit{term} \rightarrow \textit{term} / \textit{factor}$
    - $\textit{term} \rightarrow \textit{factor}$
    - $\textit{factor} \rightarrow (\textit{expression})$
    - $\textit{factor} \rightarrow id$
  - 简单表示方法
    - $E\rightarrow E + T | E - T | T$
    - $T\rightarrow T*F | T / F | F$
    - $F\rightarrow (E) | id$
    - 上面的$|$是**元符号**

## 推导
- 将待处理的串的某个**非终结符号**替换为这个非终结符号的某个产生式的**体**(用右边替换左边)
- 从**开始符号**出发，不断替换，最终可以得到不同的 **句型**
- 正式定义
  - 如果$A\rightarrow \gamma$是一个产生式，那么$\alpha A \beta \Longrightarrow \alpha \gamma \beta$
  - **最左(右)推导**：$\alpha(\beta)$中**不包含**非终结符号
    - 符号$\mathop{\Longrightarrow}\limits_{lm}^{*},\mathop{\Longrightarrow}\limits_{rm}^{*}$
  - 经过零步或多步推导出:$\mathop{\Longrightarrow}\limits^{*}$
    - 对于任何串$\alpha \mathop{\Longrightarrow}\limits^{*} \alpha$
    <div>
    - 如果$\alpha \mathop{\Longrightarrow}\limits^{*} \beta$且$\beta \Longrightarrow \gamma$则$\alpha \mathop{\Longrightarrow}\limits^{*} \gamma$
    </div>
  - 经过一步或者多步推导出:$\mathop{\Longrightarrow}\limits^{+}$
    - $\alpha \mathop{\Longrightarrow}\limits^{+} \beta$等价于$\alpha \mathop{\Longrightarrow}\limits^{*} \beta$且$\alpha \neq \beta$

## 句型/句子/语言
- **句型(Sentential form)**
  - 如果$S\mathop{\Longrightarrow}\limits^{*} \alpha$，那么$\alpha$就是文法S的句型
  - 可能既包含非终结符号又包含中介符号，也可以是空串
- **句子(Sentence)**
  - 文法的句子就是不包含非终结符号的句型
- **语言**
  - 文法G的语言就是G的句子的集合，记为L(G)
  - $\omega$在L(G)中当且仅当$\omega$是G的句子
  - 如何验证文法G确定的语言L
    - 证明G生成的每个串都在L中
    - 证明L中的每个串都能被G生成

## 语法分析树
- 推导的图形表示形式
  - **根结点**的标号是文法的<font color=red size=3>开始符号</font>
  - 每个**叶子结点**的标号是非终结符号，终结符号或者$\epsilon$
  - 每个**内部结点**的标号都是非终结符号
  - 每个内部节点表示某个产生式的一次应用
- 树的叶子组成的<font color=red size=3>序列</font>的根的文法符号的一个句型
- 一颗语法树可对应多个推到序列
  - 但只有<font color=red size=3>唯一的最左推导及最有推导</font>

### 二义性(Ambiguity)
- 定义：如果一个文法可以为某个句子生成<font color=red size=3>多棵</font>语法树，这个**文法**就是二义的
- 例子: ![二义性](/images/documents/编译原理/二义性.png)
- 程序设计语言的文法通常是无二义的

## 设计文法
- 在进行高效的语法分析前，需要对文法做以下处理：
  - 消除<font color=red size=3>二义性</font>
  - 消除<font color=red size=3>左递归</font>
    - **左递归**：文法中一个非终结符号A使得对某个串，存在一个推导$\textit{A} \mathop{\Longrightarrow}\limits^{+} \textit{A}\alpha$，则称这个文法是左递归的
    - 提取<font color=red size=3>左公因子</font>

### 二义性的消除
- 一些二义性文法可以被改成等价的无二义性的文法
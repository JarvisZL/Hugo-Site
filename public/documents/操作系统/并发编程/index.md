# 并发编程


## 并发编程

### 并发和并行
- 并发(Concurrent): 多个执行流可以不按照一定的顺序执行
- 并行(Parallel): 多个执行流可以同时执行(多个处理器)

### 线程共享
- 线程之间共享所有代码和全局变量。
- 每个线程拥有自己的堆栈，独享寄存器。

### C语言多线程编程之入门
- POSIX Threads, man 7 pthreads, 需要gcc -lpthread
- gcc -I 选项增加include path(效果等价于 #include "")

### 多线程编程之放弃

#### 放弃原子性
- 由于 **中断/异常** 的机制，导致一个线程的代码(指令)不会按照其顺序执行。
- 例子：山寨支付宝(~~有钱人的生活就是这般枯燥无味~~)
```c
int money
bool pay(int cost){
    if(money >= cost){
        money -= cost;
        return true;
    }
    else
        return false;
}
```

#### 放弃顺序性
- 由于 **编译器的优化** 指令的顺序可能和程序的顺序不一致。
- 例子：不同优化等级的for循环累加
```c
#define n 100000
int sum = 0;
for(int i = 0; i < n; ++i)
    sum++;
```

- 可以使用objdump -d 查看不同优化等级下的汇编代码。


#### 放弃可见性
- 由于 **CPU** 的加速，导致指令不一定按照其显示的顺序执行。
- 例子：两个线程分别对x，y赋值并打印
```c
int x = 0, y = 0;

void thread_1(){
  [1]  x = 1;
  [2] printf("y = %d\n",y);
}

void thread_2(){
  [3]  y = 1;
  [4]  printf("x = %d\n",x);
}
```

| x | y | 概率 | 调度顺序 |
| :---: | :---: | :---: | :---:|
| 0 | 0 | 0.2% |  ??? |
| 1 | 0 | 17.5% | 1->2->3->4|
| 0 | 1 | 82.3% | 3->4->1->2|
| 1 | 1 |  0% | 1->3->4->2|

- 结果如上表，十分出乎意料，为什么 x = 0, y = 0 会出现而 x = 1, y = 1 不出现。
- 其汇编代码如下
```
movl $1 (x) //该指令执行时间长，而后面一条指令与x没有关系，所以CPU会执行后一条指令
movl (y) %eax
```

#### 保证顺序性
- C语言使用volatile关键字修饰变量，该关键字告诉编译器，对于该变量的读写操作都不能被优化
- 可以使用内嵌汇编指令来保证内存访问的顺序
```c
extern x;

#define barrier() asm volatile ("":::"memory")

void fool(){
    x++;
    barrier();//组织编译器讲两个x++变为x = x + 2
    x++;
    y++;
}
```

#### 保证原子性
- **互斥(锁)**

# 设备驱动



## I/O设备的抽象
- cpu使用指令访问设备寄存器/设备存储。
- 在此意义上，很多东西都属于I/O设备，比如PIC,总线,DMA等。
- 而对于应用程序
  - 应用程序具有访问I/O设备有需求
  - 应用程序直接访问I/O设备是不现实的
    - I/O设备多样，应用程序难以写出portable的代码
    - 不同应用之间需要同步协调各个I/O资源的使用
- 所以操作系统应该对I/O设备进行一定的抽象。
- 需求分析
  - printf: 希望向设备写入一些数据，所以需要write功能
  - 浏览器：希望从某个TCP连接中读取数据，所以需要read功能
  - ...
- 所以分析可能需要的API为
  - read: 读出数据
  - write: 写入数据
  - ioctl: 读取/更改设备状态
- 操作系统建立一个新的抽象层，将不同的I/O设备抽象成为系统中可读可写...的对象。
- 这样就能用同一个接口去访问不同的I/O设备，实现接口的代码就是**设备驱动程序**

## 设备驱动程序
- 设备驱动程序就是硬件抽象层的实现。
- 因为硬件抽象层使得应用程序看不到实际上的I/O设备，所以其实可以创造一些虚拟的，实际上不存在的设备。
  - 如/dev/zero, /dev/null, /dev/urandom  
- 在Linux系统中，everything is a file, 所以其设备驱动也就是文件所需要的一些操作。 

### 特殊的设备-磁盘和网卡
- 磁盘的特性
  - 以数据块为单位访问
  - 使用DMA传输数据
  - 应用程序一般不会直接访问，而是由文件系统访问。
  - 大量的并发访问
- 网卡
  - 超高速设备
  - ...
- 所以针对这两个设备，linux使用了另外的单独的抽象。


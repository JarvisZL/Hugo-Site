<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Documents on 浙语临湖</title>
    <link>https://jarviszly.com/documents/</link>
    <description>Recent content in Documents on 浙语临湖</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
    <lastBuildDate>Wed, 20 May 2020 21:52:55 +0800</lastBuildDate>
    
	<atom:link href="https://jarviszly.com/documents/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>硬件初始化与操作系统加载</title>
      <link>https://jarviszly.com/documents/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%A1%AC%E4%BB%B6%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8A%A0%E8%BD%BD/</link>
      <pubDate>Wed, 20 May 2020 21:52:55 +0800</pubDate>
      
      <guid>https://jarviszly.com/documents/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%A1%AC%E4%BB%B6%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8A%A0%E8%BD%BD/</guid>
      <description>硬件初始化   硬件和软件之前存在一定的约束
 CPU reset后其处于一个确定的状态，其PC指针一般指向一段ROM,而这个ROM中存储了硬件厂商提供了firmware(固件) 此时处理器大部分特性都是关闭的比如缓存，虚存    Firmware(BIOS, UEFI)
 将用户数据加载到内存  存储介质上的二级loader(比如x86) 直接加载操作系统(嵌入式系统)      Legacy BIOS的约定
 会把引导盘的第一个扇区(512B)加载到内存，然后跳转到这部分执行    操作系统的加载   BIOS加载的512字节中包含了
 16bit $\rightarrow$ 32bit ELF32/64的通用loader    执行完16位向32位的转换后，会跳转到通用loader上执行，该通用loader默认引导盘的存储形式为    所以该loader会先将main函数的参数加载到内存，然后接着加载剩余ELF文件的第一页(4KB),然后根据第一页中ELF文件头的信息，加载剩余所需要的部分，完成ELF文件加载，就跳转到该ELF文件的入口处执行
  ELF文件开始就是从32位模式，转为64位模式，然后建立页表，设置段寄存器，完成初始化，跳转执行。
  跳转执行后，会完成很多cpu的初始化，然后切换堆栈，跳转去执行main.
  </description>
    </item>
    
    <item>
      <title>线程的互斥</title>
      <link>https://jarviszly.com/documents/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BA%92%E6%96%A5/</link>
      <pubDate>Sat, 16 May 2020 23:23:18 +0800</pubDate>
      
      <guid>https://jarviszly.com/documents/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BA%92%E6%96%A5/</guid>
      <description>在现代处理器上Peterson算法的问题  Peterson算法中的，x = 1; turn = T2; 在处理器上会变成指令store(x, 1) store(turn, T2).而因为store指令都比较耗费时间，所以在现代处理器的优化下，处理器会指令后面的指令从而导致两个线程都进入临界区。 很大的问题在于在计算机世界中，我们无法同时&amp;quot;看&amp;quot;和&amp;quot;做&amp;quot;即不能同时load 和 store.  共享内存带来更多的问题  由于不能同时load和store所以当线程共享内存时，会引发其他问题，比如多线程求sum. 四个线程求和放入同一个变量，加法对应的指令只有一条add，如果按照状态机的假设，每次只执行一条指令且指令是原子性的，那么答案应该正确。 而实际上，一条add指令可以被看成三条更小的指令：load, ++, store.而这三条指令之间的原子性等没有得到保证，所以出现错误。  x86的解决方法-增加原子性操作  x86架构提供了一些原子性操作来使得软件能够完成锁的实现，比如 lock add(一条原子性的add指令)，xchg(一条原子性的交换内存和变量的值的指令)等。 使用xchg指令可以很简单地实现自旋锁  1 2 3 4 5 6 7 8 9  int table = key; void lock(){ while(1){ int got = xchg(&amp;amp;table,NOTE); if(got == key) break; } } void unlock(){ xchg(&amp;amp;table,key);   RISC-V和Mips的解决办法-提供满足原子性的load和store  LoadReserved/Store-Conditional(LR/SC)  LR: 正常的读取某一个变量，并在相应变量上标记哪个线程所标记。 SC: 储存之前，检查标记是否对应，如果对应则正常存储，否则重做之前的指令。   LR/SC  实际上就是当LR和SC之间的操作都没有被破坏原子性等，自然这些指令就保证了原子性。  数据竞争  并不是加上了锁就能保证多线程的正确运行，比如两个线程用两把锁对同一个变量修改。 实质是 当有两个线程有两个操作访问同一段内存，且这两个操作之间没有原子性的指令(也就是不能保证两个操作执行的顺序)，就会出现数据竞争。 解决办法：对于多线程共享的内存用同一把锁。  </description>
    </item>
    
    <item>
      <title>状态机模型理解程序执行</title>
      <link>https://jarviszly.com/documents/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%8A%B6%E6%80%81%E6%9C%BA%E6%A8%A1%E5%9E%8B%E7%90%86%E8%A7%A3%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C/</link>
      <pubDate>Thu, 14 May 2020 20:30:58 +0800</pubDate>
      
      <guid>https://jarviszly.com/documents/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%8A%B6%E6%80%81%E6%9C%BA%E6%A8%A1%E5%9E%8B%E7%90%86%E8%A7%A3%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C/</guid>
      <description>单线程程序的状态机模型  不同内存和寄存器状态对应了状态机的不同节点。 大部分状态s有唯一的后继状态，存在一些指令，其有后续状态，如rdtsc(获取处理器时间戳)，rdrand(真随机数),syscall(系统调用) 状态机模型是一种理解程序和分析程序的工具  模型的应用 Time travel debugging  程序运行都是从初始结点向后跳转，那么能否从前往后？ 如果能把状态全部记下来是不合理的，但是一条指令只改变很少的寄存器和内存，所以只需要记录两个状态之间的diff就行。 gdb  target record-full 开始记录(此是需要程序已经开始执行) record stop 结束记录 reverse-step(rs)/reverse-stepi(rsi) 向前跳转    Record and Replay  记录程序执行的信息，重现某次程序执行结果。 对于确定性的指令，只需要记录下开始位置和执行了多少条指令。 对于不确定性的指令，则需要记录额外的信息，比如read系统调用，需要记录read的返回值，其读入的具体数据等。  多线程(并发)程序的状态机模型  确定了每一个线程的寄存器状态和共享内存的状态就唯一确定了一个状态机状态，多线程程序的状态机模型本身一个状态的后继状态就是多样的。 因为多线程状态机状态太多了，所以之前的应用需要重新设计。  Peterson算法：实现2个线程的互斥  两个人(P1,P2)分别有一个棋子(F1,F2)并分别可以向卫生间门上的板子上写上对方的名字。 代码如下  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  //假设及其每次原子地执行每一行代码，内存访问立即可见 int f1 = 0, f2 = 0;//棋子 int turn = P1;//厕所上的牌子 void thread_1(){ f1 = 1;//举起自己的棋子  turn = P2;//优先让别人先去  while(f2 &amp;amp;&amp;amp; turn == P2); //对方举了棋子并且还未去  //临界区  f1 = 0;//放下棋子 } void thread_2(){ f2 = 1; turn = P1; while(f1 &amp;amp;&amp;amp; turn == P1); f2 = 0; }    可以枚举出这两个线程执行顺序的所有可能来证明该算法的正确性。  </description>
    </item>
    
    <item>
      <title>并发编程</title>
      <link>https://jarviszly.com/documents/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</link>
      <pubDate>Sun, 10 May 2020 21:48:04 +0800</pubDate>
      
      <guid>https://jarviszly.com/documents/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</guid>
      <description>并发编程 并发和并行  并发(Concurrent): 多个执行流可以不按照一定的顺序执行 并行(Parallel): 多个执行流可以同时执行(多个处理器)  线程共享  线程之间共享所有代码和全局变量。 每个线程拥有自己的堆栈，独享寄存器。  C语言多线程编程之入门  POSIX Threads, man 7 pthreads, 需要gcc -lpthread gcc -I 选项增加include path(效果等价于 #include &amp;ldquo;&amp;quot;)  多线程编程之放弃 放弃原子性  由于 中断/异常 的机制，导致一个线程的代码(指令)不会按照其顺序执行。 例子：山寨支付宝(有钱人的生活就是这般枯燥无味)  1 2 3 4 5 6 7 8 9  int money bool pay(int cost){ if(money &amp;gt;= cost){ money -= cost; return true; } else return false; }   放弃顺序性  由于 编译器的优化 指令的顺序可能和程序的顺序不一致。 例子：不同优化等级的for循环累加  1 2 3 4  #define n 100000int sum = 0; for(int i = 0; i &amp;lt; n; ++i) sum++;    可以使用objdump -d 查看不同优化等级下的汇编代码。  放弃可见性  由于 CPU 的加速，导致指令不一定按照其显示的顺序执行。 例子：两个线程分别对x，y赋值并打印  1 2 3 4 5 6 7 8 9 10 11  int x = 0, y = 0; void thread_1(){ [1] x = 1; [2] printf(&amp;#34;y = %d\n&amp;#34;,y); } void thread_2(){ [3] y = 1; [4] printf(&amp;#34;x = %d\n&amp;#34;,x); }      x y 概率 调度顺序     0 0 0.</description>
    </item>
    
    <item>
      <title>归一化 FLD 人脸识别</title>
      <link>https://jarviszly.com/documents/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB/%E5%BD%92%E4%B8%80%E5%8C%96-fld-%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/</link>
      <pubDate>Thu, 26 Mar 2020 08:02:36 +0800</pubDate>
      
      <guid>https://jarviszly.com/documents/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB/%E5%BD%92%E4%B8%80%E5%8C%96-fld-%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/</guid>
      <description>特征归一化(normalization) 每维度归一  很多时候，不同维度需要统一到同样的取值范围。 训练集$x_1,\cdots ,x_n$,$x_i = (x_{i1},\cdots,x_{id})$  对于每一维数据为$x_{1j},\cdots, x_{nj}$ 取其最小值和最大值$x_{min,j},x_{max,j}$ 对于该维度的任何数据$x_{ij} = \dfrac{x_{ij} - x_{min,j}}{x_{max,j} - x_{min,j}}$    稀疏数据  每一维度归一存在的问题  如果某一维度$max = min$即出现分母为0，此时说明该维度没有什么作用，直接删去。 是否可以统一到别的区间  如[-1,1]: $x_{ij} \leftarrow 2\times (\dfrac{x_{ij} - x_{min,j}}{x_{max,j}-x_{min,j}} - 0.5)$     稀疏数据(sparse data):数据中很多纬度值为0，这在归一化中会带来问题。 维度值为零有两种可能  该维度无意义(没有采样，对该任务无影响等)，设置为0 该维度的值为0   那么对于上面两种情况，在归一化时需要分开考虑  无意义情况：仍然设置为0 值为0的情况：按照正常的归一化    $l_2$或者$l_1$归一化  有的时候各个维度之间取值范围不同是有意义的，但是不同的数据点之间的大小(如向量长度)应保持一致，即对每一个数据点进行归一化 $l_2$归一化：对于数据$x_i = (x_{i1},\cdots,x_{id})$  $x_{ij} \leftarrow \dfrac{x_{ij}}{\Vert x_i \Vert_{l_2}},\qquad \Vert x_i \Vert_{l_2} = \sqrt{x_i^Tx_i}$   $l_1$归一化：适用于非负特征，对于数据$x_i = (x_{i1},\cdots,x_{id})$  如果数据是直方图，效果最佳 $x_{ij} \leftarrow \dfrac{x_{ij}}{\Vert x_i \Vert_{l_1}},\qquad \Vert x_i \Vert_{l_1} = \sum_{j=1}^d \vert x_{ij} \vert$    服从高斯分布的归一化  有时候可以确信每一个维度都是服从高斯分布 对于每一维j,数据为$x_{1j},\cdots,x_{nj}$  计算其均值$\hat{\mu}_j$和方差$\hat{\sigma}_j^2$ 对于每一个特征值$x_{ij}\leftarrow \dfrac{x_{ij} - \hat{\mu}_j}{\hat{\sigma}_j}$    归一化测试数据  在归一化测试数据的时候，我们不能像对待训练集一样，从中取得最大值最小值平均值之类的。 需要用训练集归一化时得到的归一化模型(比如参数$x_{max,j}$)，来归一化测试集。  Fisher线性判别分析(FLD)  PCA在数据是单个高斯分布是最佳的，其有利于表示数据，但是和分类无关 在分类问题中，不同类别的分布$p(\bm{x}\vert y=i)$不能相同，所以FLD用来提取利于分类的特征。    形式化表示(二类问题)  希望找到一个投影方向，使得被投影后，两个类别的数据容易被分开。 两个类的均值 $$\bm{\mu_1} = \dfrac{1}{N_1}\sum_{y_i = 1}\bm{x_i}, \bm{\mu_2} = \dfrac{1}{N_2}\sum_{y_i = 2}\bm{x_i}$$ 投影后均值为$\bm{m_1} = \bm{w}^T\bm{\mu_1},\quad \bm{m_2} = \bm{w}^T\bm{\mu_2}$ 描述分开的程度-Fisher准则  在要求$\vert \bm{m}_2 - \bm{m}_1 \vert$尽可能大的同时，要求两个在投影后尽可能集中(不分散).</description>
    </item>
    
    <item>
      <title>语法制导的翻译</title>
      <link>https://jarviszly.com/documents/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%E7%9A%84%E7%BF%BB%E8%AF%91/</link>
      <pubDate>Thu, 19 Mar 2020 10:23:12 +0800</pubDate>
      
      <guid>https://jarviszly.com/documents/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%E7%9A%84%E7%BF%BB%E8%AF%91/</guid>
      <description>语法制导定义和语法制导翻译  语法制导定义(SDD)  将文法符号和某些属性相关联，并通过语义规则来描述如何计算属性的值。 如$E\rightarrow E_1 + T\qquad E.code = E_1.code \Vert T.code \Vert &amp;lsquo;+&#39;$ 属性code表示表达式的逆波兰表达式(后缀表达式)。   语法制导翻译(SDT)  在产生式体中加入语义动作，并在适当的时候执行动作 如$E\rightarrow E_1 + T\qquad \{ print &amp;lsquo;+&amp;rsquo;;\}$    语法制导定义(SDD)  SDD(Syntax-Derected Definition)是上下文无关文法和属性/规则的结合  属性和文法符号相关联，规则和产生式相关联   对于文法符号$X$和属性$a$，我们用$X.a$表示分析树种某个标号为$X$的结点的值.  分析树和属性值     综合属性和继承属性  综合属性(Synthesized Attribute)  结点$N$的属性值由其产生式所关联的语义规则来定义 通过$N$的子结点或者$N$本身的属性值来定义   继承属性(Inherited Atrribute)  结点$N$的属性值由其父结点产生式所关联的语义规则来定义 依赖于$N$的父结点，$N$本身和$N$兄弟结点的属性值   约束  不允许$N$的继承属性通过其子结点上的属性来定义，但允许$N$的综合属性依赖于其自身的继承属性 终结符号只有综合属性    S属性的SDD  只包含综合属性的SDD称为S属性的SDD  每个语义规则都根据产生式体的属性值来计算头部的属性值   S属性的SDD可以和LR分析器一起实现 语义规则不应该有复杂的副作用  副作用不能影响其他属性的求值 没有副作用的SDD称为属性文法    语法分析树上的SDD求值  注释语法分析树：包含了各个结点的各个属性值的语法分析树，也叫标记语法分析树。 计算顺序  如果要计算某个结点的属性a为$f(N_1.</description>
    </item>
    
    <item>
      <title>主成分分析(PCA)</title>
      <link>https://jarviszly.com/documents/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB/pca/</link>
      <pubDate>Tue, 17 Mar 2020 15:21:33 +0800</pubDate>
      
      <guid>https://jarviszly.com/documents/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB/pca/</guid>
      <description>PCA基础 常见数据特点  数据各个维度之间不是相互独立的  数据的内在维度通常远低于其表面维度。 因此需要降低维度(dimensionality reduction),PCA在降维方法中(可能)是最常用的一种。    0阶表示  假设我们的数据实际上只有一个点，可能由于噪声的存在我们收集到的数据为$x_1,x_2,\cdots,x_n$.  当噪声不存在时$x_1 = x_2 = \cdots = x_n$   不允许使用任何维度，如何最佳表示这个数据点$x$  寻找某个固定的向量$m$使得(即到每个点的距离的平方和最小) $$J_1(m) = \mathop{min}\limits_m \sum_{i=1}^n \Vert x_i - m \Vert^2$$ 假设$m$是d维的，有n个数据，那么每个数据使用的维度: $\dfrac{d}{n} \mathop{=} \limits_{n \rightarrow 0} 0$   最优解(偏导等于0)： $$m^* = \mathop{argmin}\limits_m \sum_{i=1}^n \Vert x_i - m \Vert^2 = \dfrac{1}{n}\sum_{i=1}^n x_i = \bar{x}$$  一维表示：数据维度间的线性关系  数据是$d$维的，但是内在维度可能是$m(\ll d)$维的，PCA用线性来降低维度。 $y = w^T x + b\qquad (x\in \reals^d, y\in \reals^m)$ 怎么选择方向  通过平移使得原点位于数据中心，则消除了b 第一种通过$J_1$推导即最小化误差方差的方法见教材 找方向使得方差尽可能大    形式化: 最大化方差  方差是衡量新特征包含信息多少的度量 优化目标函数 $J_2(w) = \dfrac{1}{n}\sum_{i=1}^{n} \Vert w^T(x_i-\bar{x})\Vert^2$ 问题: $J_2$可以无穷大或者无穷小(因为可以w全部乘以一个数) 解决办法：加上限制条件$\Vert w\Vert^2 = w^Tw = 1$ $$\mathop{argmax}\limits_w \dfrac{1}{n}\sum_{i=1}^{n} \Vert w^T(x_i-\bar{x})\Vert^2$$ $$s.</description>
    </item>
    
    <item>
      <title>图元生成设备级算法</title>
      <link>https://jarviszly.com/documents/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/%E5%9B%BE%E5%85%83%E7%94%9F%E6%88%90%E8%AE%BE%E5%A4%87%E7%BA%A7%E7%AE%97%E6%B3%95/</link>
      <pubDate>Mon, 16 Mar 2020 16:01:04 +0800</pubDate>
      
      <guid>https://jarviszly.com/documents/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/%E5%9B%BE%E5%85%83%E7%94%9F%E6%88%90%E8%AE%BE%E5%A4%87%E7%BA%A7%E7%AE%97%E6%B3%95/</guid>
      <description>图元生成(设备级)算法 输出图元类型  输出图元：描述图形构成的基本几何结构的子程序。 输出图元的生成：图形的设备级算法。 输出图元两大类  线画图元：矢量表示的二维图形  扫描转换：图形表示的数学方程离散化为点阵表示。   填充图元：点阵表示的二维图形  图形填充：确定图形定义点阵区域的内部点表示。      图元生成的基本操作  图元生成：将图形的几何表示转化为适当的设备操作  画点：将单个坐标位置转换成设备输出操作。 画线：将线路经换为两个指定端点位置间的多个点。    线画图元生成算法 扫描转换  将数学方程(无限的数学点)映射到有限像素区域内的实际的点 扫描转换：按光栅扫描显示原理对数学表示的线段离散取样方法  数值差分分析(DDA)算法  直接利用直线在x或者y方向的增量的线段扫描转换算法 离散取样: 使用x或y方向的单位增量间隔($\Delta x = \pm 1$或者$\Delta y = \pm 1$) 取样方向取决于直线斜率绝对值，哪个轴可变化距离大，就从哪个轴取样。 要求对于每一个像素点位置都必须取整 优点：比直接使用直线方程快 缺点：像素位置计算需要取整。  所以导致累计误差。 取整操作和浮点运算耗时。    </description>
    </item>
    
    <item>
      <title>第三部分</title>
      <link>https://jarviszly.com/documents/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86/</link>
      <pubDate>Wed, 11 Mar 2020 14:06:27 +0800</pubDate>
      
      <guid>https://jarviszly.com/documents/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86/</guid>
      <description>Data Processing Data in the real world  不完全性：主要因为数据收集。 噪声：主要来自数据收集。  数据收集设备不准确 数据传输过程有干扰   不一致：主要来自数据集成  Major tasks of data preprocessing  数据清洗(Data cleaning)  修复丢失数据，消除噪声，解决不一致性等。   数据约简(Data reduction) 数据集成(Data integration)  将不同来源的数据集成   数据转换(Data transformation)  规范化和聚合(aggregation)    Data cleaning filling in missing values  丢弃有缺失的数据(Ignore the tuple) 人工填写缺失值(Fill in the missing value manually) 使用一个全局的常数(Use a global constant)  比如$&amp;quot;unknown&amp;quot;$   使用该属性的均值(Use the attribute mean) 使用同一类中该属性的均值(Use the attribute mean of the same class) 使用可能性最大的数值(Use the most probable value)  smoothing out noisy data  noise：在数据测量过程中随机错误或者误差。 装箱(Binning):  通过数据之间相邻关系来平滑一组排序好的数据   集群(Clustering)  将相似的数据放在同一集群中。   回归(Regression)  使用数学函数   数据审计(Data editing)  使用局部的平滑(local &amp;ldquo;smoothness&amp;rdquo;) 使用全局的一致(global consistency)    correcting inconsistent data  可以使用外部引用来修正一部分不一致数据 一些工具也可用于检测已知数据约束的违反情况  Data integration  模式集成(Schema integration)  元数据可以用来帮助模式集成   冗余处理(Handling redundancy)  在集成多个数据库时可能会出现冗余 一些冗余可以通过相关性分析来检测      Data transformation  规范化(Normalization)  使得属性的取值在一个规定的小范围内   平滑(Smoothing) 聚合(Aggregation) 泛化(Generalizaiton) 属性构造(Attribute construction)  Normalization  min-max normalization  $$v^\prime = \textcolor{green}{\dfrac{v - min_A}{max_A - min_A}}\textcolor{blue}{(new\_max_A - new\_min_A) }+ \textcolor{brown}{new\_min_A}$$  $\textcolor{green}{Part 1}$: 将原数据调整为单位1。 $\textcolor{blue}{Part 2}$: 得到新数据规范化后的长度。 $\textcolor{brown}{Part 3}$: 将新数据移到原来的位置。     z-score normalization  $$v^\prime = \dfrac{v - \bar{v}}{\sigma_v}$$   decimal scalint normalization  $$v^\prime = \dfrac{v}{10^j}$$ j is the smallest int such that $max(\vert v^\prime \vert) &amp;lt; 1$    Data reduction Feature selection/Atrribute Subset selection  去除不相关的属性，从Feature或者说Attribute中挑选一个子集，使得使用该子集的结果概率分布尽可能和原数据靠近。 贪心策略(1)：每次不断挑选最好的 贪心策略(2)：每次移除最差的 贪心策略(3)：每次不断挑选最好的并移除最差的 贪心策略(4)：使用决策树 遗传算法  信息增益(Information gain)  信息熵(information entropy)  信息熵是度量样本集合纯度最常用的一种指。 当前样本集合D中第k类样本所占的比例为$p_k(1,2,\cdots,n)$,则信息熵为 $$Ent(D) = -\sum_{i=1}^n p_k \log_2 p_k$$ $Ent(D)$的值越小，D的纯度越高。   信息增益  假定离散属性a有V个可能的取值$a_1,\cdots,a_v$，如果使用a来对样本集合D进行划分，则产生V个分支节点，其中第v个包含了D中所有在属性a上取值为$a_v$的数据记为$D_v$,则可以针对$D_v$计算出信息熵，同时赋予其权重$\dfrac{\vert D_v \vert}{\vert D\vert}$ 用属性a对样本集D进行划分所得到的信息增益为 $$Gain(D,a) = Ent(D) - \sum_{i=1}^V \dfrac{\vert D_v \vert}{\vert D\vert} Ent(D_v)$$ 一般而言，信息增益越大，则意味着使用属性a进行划分所得到的纯度提升越大。所以我们可以选择属性 $$a^* = \mathop{argmax}\limits_{a} Gain(D,a)$$    </description>
    </item>
    
    <item>
      <title>图形设备输出原理</title>
      <link>https://jarviszly.com/documents/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/%E5%9B%BE%E5%BD%A2%E8%AE%BE%E5%A4%87%E8%BE%93%E5%87%BA%E5%8E%9F%E7%90%86/</link>
      <pubDate>Mon, 09 Mar 2020 13:37:22 +0800</pubDate>
      
      <guid>https://jarviszly.com/documents/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/%E5%9B%BE%E5%BD%A2%E8%AE%BE%E5%A4%87%E8%BE%93%E5%87%BA%E5%8E%9F%E7%90%86/</guid>
      <description>图形输出颜色模型 颜色模型问题  颜色模型：在特定上下文中对颜色的特性和行为的解释方法  没有一种颜色模型能够解释所有的颜色问题 一种颜色模型只能表征一定的颜色范围 要使用不同模型来帮助说明能看到不同的颜色特征。    颜色模型的光颜色提醒  光源用白色来描述  互补色：混合成白色光的两种彩色光源   适当选择两种或多种初始颜色可形成其他颜色  基色：用来生成其他颜色的两种或三种颜色。 颜色范围：使用基色获得一定范围    颜色匹配公里  基色/原色：任意互不相关的三种颜色构成颜色空间的一组基色  任意两种组合不产生另一种颜色 三基色通过适当的混合可以产生一定范围内所有的颜色。   常用三基色RGB  任意一种颜色F表达式$F = R[R] + G[G] + B[B]$(加权和) 亮度是其分亮度之和$Y_F = RY_R + GY_G + BY_B$    颜色特性描述  色彩/色度：基本色彩 纯度/彩度或者饱和度：颜色表现多纯  加入白色可以降低饱和度   明度/亮度：单位时间，角度及投射面上光源辐射的能量 三者关系：  明度：沿着颜色空间的中心线变化 色度：沿着圆周方向变化 纯度：沿着半径变化      CIE标准XYZ颜色模型  各种颜色的加色空间：XYZ是三基色，是虚颜色。 任意一个颜色可以表示为XYZ的加权和。 CIE-XYZ的特别选取：  颜色XYZ空间归一化平面来度量色度：  $X+Y+Z= 1$   颜色坐标分量Y设为其亮度值    标准函数   规范化基色权向量(X,Y,Z)可以得到</description>
    </item>
    
    <item>
      <title>模式识别系统框架</title>
      <link>https://jarviszly.com/documents/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB%E7%B3%BB%E7%BB%9F%E6%A1%86%E6%9E%B6/</link>
      <pubDate>Thu, 05 Mar 2020 09:04:58 +0800</pubDate>
      
      <guid>https://jarviszly.com/documents/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB%E7%B3%BB%E7%BB%9F%E6%A1%86%E6%9E%B6/</guid>
      <description>&lt;h1 id=&#34;最近邻和模式识别系统框架及其个模块简介&#34;&gt;最近邻和模式识别系统框架及其个模块简介&lt;/h1&gt;</description>
    </item>
    
    <item>
      <title>计算机网络-第六章</title>
      <link>https://jarviszly.com/documents/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E5%85%AD%E7%AB%A0/</link>
      <pubDate>Sat, 29 Feb 2020 13:04:41 +0800</pubDate>
      
      <guid>https://jarviszly.com/documents/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E5%85%AD%E7%AB%A0/</guid>
      <description>第六章 链路层概述  运行链路层协议的任何设备称为节点，沿着通信路径连接相邻节点的通信信道称为链路 在通过特定链路时，传输节点将数据报封装在链路层帧中，并将该帧发送到链路中。  链路层服务  成帧(framing)  链路层帧由一个数据字段和若干首部字段组成，其中网络层数据报就插在数据字段中。   链路接入(link access)  协调对共享多访问媒体的访问 媒体访问控制(MAC)协议规定了帧在链路上传输的规则。   可同时发送和接收 可靠交付  保证无差错地经链路层移动每个网络层数据报。   流控制 差错检测和纠正  链路层实现  链路层主体部分是网络适配器(网卡)，位于网卡核心的是链路层控制器，通常是一个实现了许多链路层服务的专用芯片。链路层涉及到硬件，软件和固件。 链路层帧的发送和接收  发送端：将网络层数据报封装成链路层帧，在帧的首部设置差错检测比特。 接收端：检查错误，从链路层帧中抽取网络层数据报传给上层网络层。    差错检测和纠正技术  比特级差错检测和纠正：即对从一个节点发送到另一个物理上连接的邻近节点的链路层帧中的比特损伤进行检测和纠正。 使用 差错检测和纠正比特(EDC) 来增强数据D。 通常要保护的信息除了数据报内容还包括帧首部链路级的寻址信息等。  三种检错纠错技术  奇偶校验  单个奇偶校验位  简单易用 出现偶数个bit错误时无法检测出来，且只可以检测错误。   二维奇偶检验  二位奇偶校验  发生单个错时，可以根据行和列的索引定位纠正错误。 可以检测(但不能纠正)一个分组(同一行或同一列)中任意两个比特错误的组合。 接收方检测和纠正错误的能力交错前向纠错     因特网校验和(Internet checksum)  将数据的自己作为16bit的整数并求和，这个和的 反码 形成了携带在报文段首部的 校验和。(这一步即是二进制反码求和) 二进制反码求和：从低位到高位逐列进行和计算,如果最高位(16位)进位,则得到的结果加1,一直循环到最高位没有进位为止.</description>
    </item>
    
    <item>
      <title>计算机网络-第七章</title>
      <link>https://jarviszly.com/documents/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%83%E7%AB%A0/</link>
      <pubDate>Sat, 29 Feb 2020 13:03:58 +0800</pubDate>
      
      <guid>https://jarviszly.com/documents/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%83%E7%AB%A0/</guid>
      <description>无线网络和移动网络 基本概念   基站：负责协调与之关联的多个无线主机之间数据的传输。比如蜂窝塔，802.11无线LAN中的接入点。
  基础设施模式：与基站关联的主机以此模式运行。
  网络基础设施：无线主机希望与之进行通信的更大的网络。
  单跳和多跳：
 单跳网络：在传统的无线局域网(WLAN)中，每个客户端均通过一条与AP相连的无线链路来访问网络，用户如果要进行相互通信的话，必须首先访问一个固定的接入点(AP)，这种网络结构被称为单跳网络。 多跳网络：在无线多跳网络中，源结点到目的结点之间的典型路径是由多跳组成的，该路径上的中间结点充当转发结点。 单跳和多跳     信噪比(SNR)：所收到的信号和噪声强度的相对测量，信噪比越高，接收方越容易从背景噪声中提取信号。
  比特差错率(BER)：接收方收到有错传输比特的概率。
  无线网络和有线网络的区别  无线网络中信号强度逐渐递减。 无线网络中信号会受到其他源的影响。 无线网络中由于电磁波被反射等影响会出现多径传播。  Ad-Hoc Network  Ad-hoc网络是由相互直接通信的各个设备组成的网络,常常绕过集中的接入点。是点到点的网络，没有基站。  IEEE 802.11 wireless LAN(WiFi)  工作的主要频段：2.4GHz 和 5GHz 体系结构(Architecture):  BSS(基本服务集)：包含一个或多个无线站点和一个接入点(AP)的中央基站，每一个站点和基站都有理论上唯一的6字节的MAC地址存储在该站的适配器(网卡)中。 ESS(拓展服务集)：由DS(分布式系统)连接多个BSS构成，这个DS可以是交换机，有线网络或无线网络，其作为一个逻辑局域网出现。    IEEE 802.11 services  Distribution service and Intergration service  Distribution service: 在ESS中如果一个帧要从一个站点到达另一个BSS中另一个站点，则需要使用该服务，如果两个站点在同一个BSS中，则该服务逻辑上使用单个AP. Intergration service: 当一个站点要发送一个帧到达LAN中时，就使用Intergration service。 DS and IS  IEEE 802.</description>
    </item>
    
    <item>
      <title>计算机网络-第三章</title>
      <link>https://jarviszly.com/documents/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%89%E7%AB%A0/</link>
      <pubDate>Sat, 29 Feb 2020 13:03:02 +0800</pubDate>
      
      <guid>https://jarviszly.com/documents/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%89%E7%AB%A0/</guid>
      <description>第三章 运输层 概述  运输层协议为运行在不同主机上的应用进程之间提供了逻辑通信，其只工作在端系统上，将应用进程的报文移动到网络边缘(网络层)，或者从网络层获取报文。 两个主要的协议：  UDP(用户数据协议)，不可靠的，无序的，无连接的。 TCP(传输控制协议)，可靠的，有序的，面向连接的。   运输层将主机之间的交付扩展到进程间的交互被称为 运输层的多路复用和多路分解。  多路复用和多路分解  $&amp;lt;IP，Port&amp;gt;$这样被称为套接字。 将运输层报文段中数据交付到正确的 套接字的做工称为 多路分解。 从不同套接字收集数据，加上首部，生成报文段后传递到网络层 ，这个工作称为 多路复用。 多路复用和多路分解的要求：  套接字有唯一标识。 报文段中有特殊字段指示所需交付的套接字，即源端口号和目的端口号。 端口号是16比特数，其中$0\sim 1023$这部分是 周知端口号，用于如HTTP等协议使用，其他可以随意分配。 报文段格式     无连接的多路复用和多路分解(UDP)  UDP套接字由一个 二元组(目的主机IP，目的端口号) 唯一确定，在这里源端口号和源IP作用是作为返回地址。  面向连接的多路复用和多路分解(TCP)  TCP套接字由一个 四元组(源IP,源端口号，目的IP，目的端口号) 唯一确定，只有四个属性全部一致的报文才会被发送到同一个端口上，除非该TCP报文段首部的 连接建立位是置位(即该报文用来建立连接)，则都会发送给主机上用来建立连接的端口上。  UDP(用户数据)协议  仅仅提供了复用/分解服务和差错检验服务。  报文段格式：UDP报文格式  其中Checksum用于差错检验，其计算方法和因特网校验和一样，二进制求和取反。 UDP首部为8字节。   UDP协议的优点：  UDP能够立马发送应用层传下来的数据，不会有过分的延迟传输，对于实时应用是很重要的。 不需要建立连接，不需要维持连接，所以没有连接延迟和维持连接的开销。    可靠数据传输原理  经 完全可靠信道传输 的FSM(有限状态机器)  发送方和接收方都有数据就传输，有数据就接收。   经 具有比特差错信道传输 的FSM  加入 差错检验和接收端反馈(ACK/NAK)，即发送后 停止等待 但没有考虑到接收端发送的ACK/NAK也可能受损，解决方法是在数据分组中加入 序号 字段 或者也可不使用NAK而是发送ACK时候带上ACK的分组序号，由发送方判断是否是刚刚发送的分组的ACK从而决定是否要重发。   经 具有比特差错和丢包信道传输 的FSM  加入 定时器，在时间阈值内没有收到正确的ACK则重发。    流水线可靠数据传输协议  针对rdt3的停止等待导致信道利用率低下的问题，改用不使用停止等待，而是允许发送一定量的分组而不需要得到确认。 流水线里面的差错恢复有 回退N步(滑动窗口) 和 选择重传 回退N步    在rdt3的基础上最多允许不加确认的条件下传输N个分组。 一旦超时，则重发从[base,nextseqnum-1]的全部分组。 同时在本协议内，接收端丢弃所有失序分组，也就是说如果第i个分组出现丢包，则i后面的分组都会被接收端丢弃。   选择重传  发送方和接收方各自维护一个大小为N的窗口。 发送方的事件和动作  1.</description>
    </item>
    
    <item>
      <title>计算机网络-第四章</title>
      <link>https://jarviszly.com/documents/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E5%9B%9B%E7%AB%A0/</link>
      <pubDate>Sat, 29 Feb 2020 13:01:43 +0800</pubDate>
      
      <guid>https://jarviszly.com/documents/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E5%9B%9B%E7%AB%A0/</guid>
      <description>第四章 转发和交换(路由选择) 转发  是网络层：数据平面实现的唯一功能。 是指将一个分组从一个输入链路接口转移到适当的输出链路接口的路由器本地动作，时间尺度很短。  交换(路由选择)  是网络层：控制平面的功能，当分组从发送方流向接收方时，网络层需要决定这些分组采用的路由或路径，计算这些路径的算法称为 路由选择算法 是指确定分组从发送方到接收方所采取的端到端路径的网络范围处理过程，事件尺度相对更长。  转发表  每个网络路由器都有一个转发表，路由器在检测到分组首部的若干字段后，用这些首部值在转发表中索引，从而确定分组转发的输出链路接口。 链路层交换机时根据链路层帧首部的字段(如MAC地址)进行转发，而 路由器是根据网络层数据报中的首部(如IP地址)进行转发  路由器工作原理 路由器体系结构 体系结构  交换  经内存交换：通过终端路由选择处理器 经总线交换：通过给分组打上标签，到达本地输出链路后去除标签。 经互联网络交换：允许并行，交换时将沿途结点封锁。    基于目的地的转发  路由器转发表采用前缀匹配的方式生成表项，对于每一个链路接口，其目的地址范围的前缀为表项中的前缀匹配。 在收到分组时，路由器用分组的目的地址和表项中的前缀匹配，匹配成功则将该分组转发到对应的链路接口。 当存在多个成功匹配时，采用 最长前缀匹配规则，转发到匹配长度最长的那个链路接口。  分组调度  排队的分组如何经输出链路传输。 先进先出(FIFO) 优先权排队  将到达输出链路的分组按照优先级分成多个类，优先级高的类先传输，类内采用FIFO的方式。 非抢占式优先权排队：一旦分组开始被传输，即使此时有更高优先级的分组到达，该分组的传输也不会被打断。   循环排队规则  也将分组分成多个类，循环调度器在类之间轮流传输。   加权公平排队  和循环排队类似，但是在第i个类有需要发送的分组的任何时间间隔中，都能保证该类等待发送的分组中有$w_i/(\sum w_j)$的部分接收到了发送服务。    网际协议：IP IPv4 IPv4数据报格式 IPv4   版本号：规定了数据报IP协议版本，路由器根据该部分决定如何识别解释后面的部分 首部长度：一般为20字节。 服务类型：说明该IP数据报是什么类型。 数据报长度：整个IP数据报总长度。 标识，标志，片偏移：和IP分片相关。 寿命(TTL): 确保数据报不会再网络中循环，没经过一个路由器该值-1，为0时丢弃。 上层协议：指示了IP数据报的数据部分应该交给哪一个特定的运输层协议。 首部校验和：帮助路由器检测IP数据报中的比特错误。 源/目的IP地址，选项，数据。  IPv4数据报分片  分片原因：由于不同的链路层协议的 最大传送单元不一样，有时一个链路层帧并不能完全承载一个IP数据报的内容，故需要将IP数据报分片。 最大传送单元：一个链路层帧能够承载的最大数据量。 IPv4将重组IP数据报的工作交给了端系统。 IPv4数据报分片利用标识，标志，片偏移三个字段：  发送主机通常将它发送的每一个数据报的标识号依次加1.</description>
    </item>
    
    <item>
      <title>计算机网络-第五章</title>
      <link>https://jarviszly.com/documents/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0/</link>
      <pubDate>Sat, 29 Feb 2020 13:00:33 +0800</pubDate>
      
      <guid>https://jarviszly.com/documents/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0/</guid>
      <description>第五章 路由选择算法  路由选择算法的目的是从发送方到接收方的过程中确定一条通过路由器网络的好的路径。  分类  集中式路由选择算法和分散式路由选择算法  集中式路由选择算法：用完整的全局性的网络信息计算出最低开销路径，以所有节点之间的连通性及所有链路的开销作为输入，如链路状态算法(LS) 分散式路由选择算法：路由器以 迭代，分布式方法计算出最低开销路径，每个节点仅有与其直接相连的链路开销信息即可开始工作。如 距离向量算法(DV)   静态路由选择算法和动态路由选择算法 负载敏感算法和负载迟钝算法  现在因特网路由选择算法(RIP,OSPF,BGP)都是负载迟钝算法。    LS算法  在该算法中，网络拓扑和所有链路开销都是已知的。实践中是通过让每个节点向网络中广播链路状态分组来完成的。其中链路状态分组包含和自己相连的链路的开销信息，这常常由 链路状态广播算法完成。 使用协议：OSPF，使用的算法：Dijkstra算法，复杂度$O({|V|}^2)$  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  1 Initialization: 2 N’ = {u} 3 for all nodes v 4 if v is a neighbor of u 5 then D(v) = c(u, v) 6 else D(v) = ∞ 7 8 Loop 9 find w not in N’ such that D(w) is a minimum 10 add w to N’ 11 update D(v) for each neighbor v of w and not in N’: 12 D(v) = min(D(v), D(w)+ c(w, v) ) 13 /* new cost to v is either old cost to v or known 14 least path cost to w plus cost from w to v */ 15 until N’= N    链路状态算法运行过程： table  存在的问题：拥塞敏感的选择振荡  在拥塞敏感且将路径负载当作开销的情况下，所有路由器同时运行LS算法，会使得由于选择了某一条目前最短开销路径而导致网络中路径开销改变，LS算法得出的最短开销路径会不断摇摆振荡。 解决办法是 使每台路由器广播链路状态分组的时间随机化。    DV算法  该算法是一种 迭代的，异步的，分布式的算法，使用的协议有BGP，RIP.</description>
    </item>
    
    <item>
      <title>计算机网络-拥塞和Qos</title>
      <link>https://jarviszly.com/documents/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%8B%A5%E5%A1%9E%E5%92%8Cqos/</link>
      <pubDate>Sat, 29 Feb 2020 12:59:22 +0800</pubDate>
      
      <guid>https://jarviszly.com/documents/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%8B%A5%E5%A1%9E%E5%92%8Cqos/</guid>
      <description>拥塞和Qos 拥塞 拥塞原因  大量分组在网络上传输，数量超出路由器的处理能力。  拥塞代价  造成丢包，时延；重传使得浪费之前发送的资源。  拥塞控制方法   抑制分组(choke packet): 产生拥塞的路由器通过特定协议(如ICMP)向源端系统发送抑制分组来抑制源端系统的分组发送。
  反向施压(Backpressure): 当传播时间大于传输时间时，choke packet往往没有作用，则通过产生拥塞路由器向前面一个路由器反向施压抑制前面路由器的发送，这样传递下去，最终影响到源端系统。
  标志位(Warning bit): 通过在分组上设置一个标志位来告诉端系统可能发生拥塞。
 前向标记(FECN): 发生拥塞相同的方向 后向标记(BECN): 发生拥塞相反的方向    拥塞窗口：使用在端系统上(如TCP)
  早期随机丢弃(RED): 作用在路由器上，该方式设置一个下限 $L_{min}$，一个上限 $L_{max}$。
 当队列的长度小于小于下限时，保证不会丢掉分组 当队列的长度介于上下限之间时，对于每一个接收到的分组，路由器以概率 p丢弃 当队列长度完全大于上限时，丢弃接收到的分组。    流量整形（Traffic shaping): 在建立连接之后，端系统和路由器之间协商流量整形的方式。
 约定数据速率(CIR): RED方式。 漏桶：通过像漏斗一样的东西控制流量，输入速率随意，输出速率固定。 令牌桶：允许多变的输出速率。  令牌桶容量：一次性最多能够输出分组的数量。 令牌产生的速率：用来控制输出分组的平均速率 可以在令牌桶后面连接一个容量为1的令牌桶来控制峰值速率      Qos的两种服务 ISA(Integrated Services Architecture)  由于太复杂，现在还没用。  DS(Differentiated Services)差异化服务  使用IPv4和IPv6里面的服务类型和流量类型来区分不同的分组的重要性。  </description>
    </item>
    
    <item>
      <title>微电子笔记第三章</title>
      <link>https://jarviszly.com/documents/%E5%BE%AE%E7%94%B5%E5%AD%90%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%89%E7%AB%A0/</link>
      <pubDate>Sat, 29 Feb 2020 12:58:03 +0800</pubDate>
      
      <guid>https://jarviszly.com/documents/%E5%BE%AE%E7%94%B5%E5%AD%90%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%89%E7%AB%A0/</guid>
      <description>半导体物理基础 半导体材料  根据物体导电能力分为导体,绝缘体，半导体，其中导体电阻率$\rho&amp;lt;10^{-4} \Omega\cdot cm$,绝缘体电阻率$\rho &amp;gt; 10^9 \Omega\cdot cm$,半导体电阻率介于两者之间。 半导体导电能力和 温度，光照，掺杂浓度相关。 典型半导体有 硅Si,锗Ge,砷化镓GaAs 半导体共价键结构：一般为四价元素，最外层四个电子被称为价电子，和周围四个原子的价电子分别形成共价键。  本征半导体,空穴及导电作用  本征半导体：化学成分纯净的半导体，物理结构呈单晶体形态。纯度到要达到9个9 载流子：可以自由移动的带电粒子。 电导率：与材料单位体积中所含的载流子数量相关，载流子浓度越高，电导率越高。 本征激发：半导体受到光，热激发时，某些电子可以从外界获得挣脱共价键束缚的能量，从而离开原子成为自由电子，同时再共价键中留下相同数量的空穴。 空穴：共价键中的空位。(空穴的出现是半导体区别于导体的一个特点) 电子空穴对：由热激发而产生的自由电子和空穴对。 空穴的移动是依靠相邻共价键中的价电子依次填充空穴来实现的。 复合：当自由电子遇到空穴后相互结合形成一个新的共价键。 在温度一定时，本征激发和复合会达到动态平衡。 重要特性：  本征半导体中自由电子和空穴总是成对产生，数量随温度增高而显著增加。 空穴的导电作用   本征半导体的缺点：载流子少，导电性差，温度稳定性差。  杂质半导体  定义：在本征半导体中掺入某些微量元素作为杂质，可以使半导体的导电性发生显著变化，主要掺入的是三价元素或五价元素。 P型半导体：掺入三价杂质元素(如硼，镓，铟)等。  因三价原子和硅原子形成共价键时，缺少一个价电子从而留下一个空穴 在P型半导体中，空穴(p)是多数载流子(多子)，主要由掺杂形成，自由电子(n)是少数载流子(少子)，由热激发形成，空穴很容易俘获电子，使得杂质原子成为负离子，三价杂质因此也被称为受主杂质($N_A$) 满足公式 $N_A+n = p$   N型半导体：掺入五价杂质元素(如磷)。  因五价原子只有四个价电子可以和硅的价电子形成共价键，所以多余的一个价电子没有束缚而称为自由电子。 在N型半导体中，自由电子(n)是多子，主要由掺杂形成，空穴(p)是少子，由热激发形成，提供自由电子的五价原子成为正离子，被称为施主杂质($N_D$) 满足公式 $N_D+p = n$    载流子的漂移和扩散  漂移电流：在电场作用下，载流子在电场中的漂移运动形成的电流。  $v_n = -\mu_n E$,$v_p = \mu_p E$,其中$\mu$为对应的载流子迁移率。 $I = -\nu\cdot Width\cdot Height\cdot n\cdot q$   扩散电流：因浓度差，载流子从高浓度向低浓度扩散而形成的电流。  PN结  在一块本征半导体两侧扩散不同的杂质原子，使得一边为P型一边为N型，两边多子由于浓度差，向对方扩撒，从而内部的空间电荷区形成一个电场，内电场抑制多子扩散，同时促进少子漂移，最终达到平衡。P，N型半导体接合面，离子薄层形成的 空间电荷区被称为PN结 单向导电性  在PN结外部加上电压，当P区电位高于N区电位，称为加上了正向电压，简称为正偏，反之为反向电压，简称反偏。 正偏时，外部电压促进多子扩散，从而导致中间空间电荷区变窄，PN结呈现的状态是低电阻状态，大的正向扩散电流 反偏时，外部电压一直多子扩散，促进少子漂移，从而导致空间电荷区变宽，PN结呈现的状态是高电压，小的反向漂移电流。在一定温度下，本征激发形成的少子数量一定，此时形成的漂移电流一定，和外部电压无关，称为反向饱和电流。 V-I特性表达式: $i_D = I_s(e^{V_d/V_T}-1)$，其中$I_s$为反向饱和电流，$V_T$为温度的电压当量，常温(300K)下$V_T = \dfrac{kT}{q} = 26mv$   反向击穿  当反向电压达到一定数值时，反向电流突然快速增加的现象。 分为电击穿(雪崩击穿，齐纳击穿)此时可逆，热击穿此时不可逆。 雪崩击穿：空间电荷区的电子在电场中获得足够的动能撞击其他原子从而产生更多的自由电子-空穴对，新的电子又同样撞击其他原子，如此连锁反应，使得载流子数量雪崩式增加，从而导致电流急剧加大。具有正的温度系数 齐纳击穿：反向电压足够大时，在电场的作用下，价电子之间的共价键被拉断，从而价电子变成自由电子，自由电子在电场的作用下移动到N区，空穴移动到P区，使得电流急剧增大。常发生在掺杂浓度较高的PN结中，具有负的温度系数(温度升高，共价键更容易被破坏)。    二极管 PN结上加上引线和封装就是一个二极管。</description>
    </item>
    
    <item>
      <title>微电子笔记</title>
      <link>https://jarviszly.com/documents/%E5%BE%AE%E7%94%B5%E5%AD%90%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Sat, 29 Feb 2020 12:57:01 +0800</pubDate>
      
      <guid>https://jarviszly.com/documents/%E5%BE%AE%E7%94%B5%E5%AD%90%E7%AC%94%E8%AE%B0/</guid>
      <description>第一章 电子计算机  电子管时代：  1940s-1950s ENIAC(1946,ABC公司)，电子数字积分计算器。   晶体管时代：  1950s-1960s 晶体管：一种用以代替真空管的电子信号放大元件。 1947年贝尔实验室制造成功了第一个半导体晶体管 1949年贝尔实验室做出了第一个锗PNP型晶体管。 1956年bardeen,Shockley,Brattain获得诺贝尔物理学奖。 TRADIC(1954):世界上第一台全晶体管计算机。   集成电路时代：  1960s- 1958年，Jack Kilby发明了第一块锗集成电路振荡器。（2000诺贝尔物理学奖） 1970年，Intel推出第一个商用 动态随机存储器(DRAM)1103,容量1 Kbits,标志这大规模集成电路(LSI)出现。 1978年，64kbDRAM出现标志这进入了超大规模集成电路时代。    摩尔定律  定义：IC集成度每一年提高一倍，即技术每两年提升一代，1975年修正：进入80年代后，技术每3年提升一代。 技术基础：不断缩小的晶体管尺寸。  集成电路规模  SSI: $&amp;lt;10^2$ MSI: $10^2$~$10^3$ LSI: $10^3$~$10^5$ VLSI: $10^5$~$10^7$ ULSI: $10^7$~$10^9$ GLSI: $&amp;gt;10^9$  微电子学定义 研究在固体（主要是半导体材料）上构成的微小化电路及系统的电子学分支，主要是研究电子或离子在固体材料中的运动规律及其应用，并利用它实现电磁信号和信息处理功能的电子科学。它以实现电路和系统的集成为目的。微电子学中实现的电路和系统又称为集成电路和集成系统，是微小化的；在微电子学中的空间尺寸通常是以微米（μm，1μm=10 − 6m）和纳米（nm，1nm=10 − 9 m）为单位的。
微电子学应用领域  逻辑电路 储存电路 通信电路 平板显示 &amp;hellip;&amp;hellip;  微电子技术 微电子技术是随着集成电路尤其是超大规模集成电路发展起来的技术。主要包括了电路系统设计，器件物理，工艺技术，材料制备，测试和封装的专门的技术，是微电子学中各项工艺技术的总和。
集成电路  定义：是通过一系列加工工艺，将晶体管按照一定的电路互连在一块半导体单晶片上并封装在外壳中来执行特定的电路或系统功能的电路。 制造过程：电路设计，工艺制造，测试封装。 核心：单元器件 晶体管是组成集成电路最基本的单位。 分类：  器件构造模型：  双极集成电路：由双极晶体管构成，如PNP型、NPN型，优点是速度快，驱动力强，缺点是集成度不高，功耗大 金属-氧化物-半导体(MOS)集成电路：如NMOS,PMOS,CMOS，优点是集成高，功耗小，随着特征尺寸缩小，速度也快。 双极-MOS集成电路：综合上面，有上面的优点，但制作工艺复杂。   集成规模：见上 制作工艺：  单片集成电路：电路中所有的元器件都集成在同一块半导体基片上的集成电路。 混合集成电路： 薄膜集成电路，厚膜集成电路   应用领域：  数字集成电路：处理数字信号的集成电路，即采用二进制方式进行数字计算和逻辑函数运算的集成电路 模拟集成电路：处理模拟信号的集成电路(连续变化的信号)，分线性集成(运算放大器)和非线性集成(振荡器) 数模混合集成电路：如数模转化器。      微电子学器件  定义：可以构成集成电路的最小单元。 最具代表性器件：场效应晶体管。  微电子学核心研究内容之一就是怎么实现更小尺寸的晶体管</description>
    </item>
    
    <item>
      <title>组合数学</title>
      <link>https://jarviszly.com/documents/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/</link>
      <pubDate>Sat, 29 Feb 2020 12:55:20 +0800</pubDate>
      
      <guid>https://jarviszly.com/documents/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/</guid>
      <description>&lt;h1 id=&#34;基本计数&#34;&gt;基本计数&lt;/h1&gt;</description>
    </item>
    
    <item>
      <title>数据库</title>
      <link>https://jarviszly.com/documents/%E6%95%B0%E6%8D%AE%E5%BA%93/</link>
      <pubDate>Sat, 29 Feb 2020 12:53:01 +0800</pubDate>
      
      <guid>https://jarviszly.com/documents/%E6%95%B0%E6%8D%AE%E5%BA%93/</guid>
      <description>数据库 Tips  注意只有$\cdots$的的时候，在关系代数中是考虑被减数取哪一个关系，而在关系演算中是考虑是否要多加一项来保证类似于选过课，买过商品的约束，在sql中考虑是否通过类似于where sno in (select sno from SC where&amp;hellip;)来保证  关于加入成绩的关系代数  选修了CS系开设的所有课程且所修的所有课程成绩合格 $$(\pi_{sno,cno}(L) \div \pi_{cno}(\sigma_{dept = &amp;lsquo;CS&amp;rsquo;}(C))) - \pi_{sno}(\sigma_{g &amp;lt; 60}(L))$$ 选修了CS系开设的所有课程且这些课程的成绩合格 $$\pi_{sno,cno}(\sigma_{g \geq 60}(L))\div \pi_{cno}(\sigma_{dept = &amp;lsquo;CS&amp;rsquo;}(C))$$ 选修了自己院系开设的所有课程且这些课程成绩合格 $$\pi_{sno}(L) - \pi_{sno}[\pi_{sno,cno}(C \infty S) - \pi_{sno,cno}(\sigma_{g \geq 60}(L))]$$ 像这种对自己院系(城市)的所有什么做了什么的情况通常用减法来表示除法  两重所有  通过所有销售过所有的商品的供应商购买过商品的客户
销售过所有商品的供应商：$\pi_{aid,pid}(O) \div \pi_{pid}(P)$ $$\pi_{cid,aid}(O) \div (\pi_{aid,pid}(O) \div \pi_{pid}(P))$$ 向NY市所有客户都销售过所有单价大于1的商品的供应商
此处并非使用两个除法，需要搞清楚条件是什么!!,除数应该是NY市的客户和单价大于1的商品两个集合的笛卡尔乘积：$\pi_{cid}(\sigma_{city =&#39;NY&amp;rsquo;}(C)) \times \pi_{pid}(\sigma_{price &amp;gt; 1}(P))$ $$\pi_{aid,cid,pid}(O)\div [\pi_{cid}(\sigma_{city =&#39;NY&amp;rsquo;}(C)) \times \pi_{pid}(\sigma_{price &amp;gt; 1}(P))]$$  </description>
    </item>
    
    <item>
      <title>语法分析</title>
      <link>https://jarviszly.com/documents/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/</link>
      <pubDate>Thu, 27 Feb 2020 10:06:04 +0800</pubDate>
      
      <guid>https://jarviszly.com/documents/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/</guid>
      <description>语法分析 语法分析器  基本作用  从词法分析器获得词法单元序列，确认该序列是否可以由语言的文法生成 对于语法错误的程序，报告错误信息 对于语法正确的程序，生成语法分析树(语法树) 语法分析器    分类  自顶向下语法分析器(用于处理LL文法)  从语法分析树的根部开始构造语法分析树   自底向上语法分析器(用于处理LR文法)  从语法分析树的叶子开始构造语法分析树   两个第一个L都表示从左到右，逐个扫描词法单元    上下文无关文法(CFG) 组成部分  终结符号：组成串的基本符号(词法单元名字) 非终结符号：表示串的集合的语法变量  在程序设计语言中通常对应于某个程序构造如$\textit{stmt}$   开始符号：某个被指定的非终结符号  对应的串的集合就是文法的语言   产生式：描述将终结符号和非终结符号组成串的方法  形式：头(左)部$\rightarrow$ 体(右)部 头部是一个非终结符号，右边是一个符号串 例如:$\textit{expression} \rightarrow \textit{expression} + \textit{term}$(加法表达式)    例子  简单算术表达式文法  终结符号: $id,+,-,*,/,(,)$ 非终结符号：$\textit{expression}, \textit{term}, \textit{factor}$ 开始符号：$\textit{expression}$ 产生式集合  $\textit{expression} \rightarrow \textit{expression} + \textit{term}$ $\textit{expression} \rightarrow \textit{expression} - \textit{term}$ $\textit{expression} \rightarrow \textit{term}$ $\textit{term} \rightarrow \textit{term} * \textit{factor}$ $\textit{term} \rightarrow \textit{term} / \textit{factor}$ $\textit{term} \rightarrow \textit{factor}$ $\textit{factor} \rightarrow (\textit{expression})$ $\textit{factor} \rightarrow id$   简单表示方法  $E\rightarrow E + T | E - T | T$ $T\rightarrow T*F | T / F | F$ $F\rightarrow (E) | id$ 上面的$|$是元符号      推导  将待处理的串的某个非终结符号替换为这个非终结符号的某个产生式的体(用右边替换左边) 从开始符号出发，不断替换，最终可以得到不同的 句型 正式定义   如果$A\rightarrow \gamma$是一个产生式，那么$\alpha A \beta \Longrightarrow \alpha \gamma \beta$</description>
    </item>
    
    <item>
      <title>第二部分</title>
      <link>https://jarviszly.com/documents/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86/</link>
      <pubDate>Wed, 26 Feb 2020 19:36:58 +0800</pubDate>
      
      <guid>https://jarviszly.com/documents/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86/</guid>
      <description>&lt;h1 id=&#34;data-cube-and-olap&#34;&gt;Data Cube And OLAP&lt;/h1&gt;</description>
    </item>
    
    <item>
      <title>数学基础</title>
      <link>https://jarviszly.com/documents/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Sun, 23 Feb 2020 15:36:25 +0800</pubDate>
      
      <guid>https://jarviszly.com/documents/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/</guid>
      <description>&lt;h1 id=&#34;模式识别数学基础&#34;&gt;模式识别数学基础&lt;/h1&gt;</description>
    </item>
    
    <item>
      <title>计算机图形学概论</title>
      <link>https://jarviszly.com/documents/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E6%A6%82%E8%AE%BA/</link>
      <pubDate>Mon, 17 Feb 2020 14:38:35 +0800</pubDate>
      
      <guid>https://jarviszly.com/documents/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E6%A6%82%E8%AE%BA/</guid>
      <description>&lt;h1 id=&#34;概论&#34;&gt;概论&lt;/h1&gt;</description>
    </item>
    
  </channel>
</rss>
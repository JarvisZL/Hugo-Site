<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Documents on 浙语临湖</title>
    <link>https://jarviszly.com/documents/</link>
    <description>Recent content in Documents on 浙语临湖</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
    <lastBuildDate>Sat, 27 Jun 2020 10:04:53 +0800</lastBuildDate>
    
	<atom:link href="https://jarviszly.com/documents/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>崩溃一致性</title>
      <link>https://jarviszly.com/documents/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B4%A9%E6%BA%83%E4%B8%80%E8%87%B4%E6%80%A7/</link>
      <pubDate>Sat, 27 Jun 2020 10:04:53 +0800</pubDate>
      
      <guid>https://jarviszly.com/documents/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B4%A9%E6%BA%83%E4%B8%80%E8%87%B4%E6%80%A7/</guid>
      <description>崩溃一致性  希望文件系统在任何时候都能保持一致性。 导致不一致的原因: 数据结构的维护需要多个数据块的写入  RAID: $write(V_0) \rightarrow write(A_0), write(B_0)$ ext2(文件追写一块): $write(inode),write(bitmap),write(data)$   磁盘收到多个I/O请求，磁盘是有权利调换一些顺序的，除非收到一个flush请求。 比如上面第二种情况  inode写入了：导致指向了没有分配的地方，以后可能被分配导致两个文件共享这部分，十分严重的问题.(corrupt fs) bitmap写入了：导致了分配了一块，但是没有办法访问到也没有办法free，导致了(deadblock). data写入了：相当于写了一些garbage到文件系统中 inode,bitmap写入了：数据未写入，相当于文件内容出错(corrupt file) inode,data写入了：同样可能导致共享问题(corrupt fs) bitmap,data写入了：deadblock    fsck(File System Checking)  根据磁盘中已有的信息，恢复出最可能的数据结构的状态，但有时候很难决定什么是对的结构。 fsck也是一个程序，有可能在其运行过程中发生崩溃，这时文件系统可能进入彻底无法恢复的状态 所以需要一个更加&amp;quot;constructive&amp;quot;的办法实现崩溃一致性，所以提出了journaling.  journaling  实现append-only的block vector  比如append(234)到1后面，要不然就全部写入要不然就认为全部没有写入的原子append 写完234后使用一次flush，成功返回后写入一个OK标记再flush，只有第二次flush返回成功才认为前面已经都写入磁盘。   实现数据结构有两种方法，第一种是常见的记录其结构，另一种是记录使用该数据结构的一些操作，而在实现了append-only的基础上，可以使用append-only记录这些操作。  从而保证先将操作记录写入磁盘，然后再执行这些操作。   journaling的优化  合并多个flush标记Tx减少log大小 不记录Txbegin,Txend而是记录checksum,Tx的长度    </description>
    </item>
    
    <item>
      <title>持久数据的可靠性RAID</title>
      <link>https://jarviszly.com/documents/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%8C%81%E4%B9%85%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7raid/</link>
      <pubDate>Fri, 26 Jun 2020 11:10:06 +0800</pubDate>
      
      <guid>https://jarviszly.com/documents/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%8C%81%E4%B9%85%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7raid/</guid>
      <description>持久数据的可靠性  增加持久数据可靠性的方法-备份  random corruption(某块随机损坏)和FAT备份  损坏情况  元数据(FAT)损坏-高破坏性 系统文件损坏-可能造成无法开机 数据文件损坏-丢失一个文件，勉强可以接受   应对部分数据损坏-自动备份最重要的数据(FAT)$\times k$  k由文件系统初始化时设置 更改FAT时需要对多个FAT同时更改   性能影响  FAT读取：不受影响，从任意一个读取即可，当FAT-i损坏的时候，从FAT-i+1读取即可 FAT更新：需要同时写入k个，但因为FAT部分经常访问所以其在内存中有副本，所以其实写入磁盘的频率很低   可靠性分析：  假设有一个FAT有n个cluster，每个以p概率损坏 可以抵抗任意连续不超过n个的损坏。 原来存在损坏$1-(1-p)^n$变成$1-(1-p^k)^n$   FAT损坏恢复(M5)  mmap将所有cluster读入内存 分类所有的cluster(目录文件，bitmap头，bitmap数据) 然后解析目录文件找到bitmap头，根据假设bitmap头后面的一些cluster就是bitmap数据，可以进行简单的恢复，或者根据相似性去进行更严谨的恢复    fail-stop(整块磁盘坏掉)和RAID  RAID(廉价磁盘冗余阵列)  把多块磁盘虚拟成一块虚拟磁盘(RAID) 允许任意一块磁盘的损坏 利用带宽  比如有两个磁盘，需要读取1234，则可以发成从A中读12，从B中读34，可以通过DMA并行完成，从而提高读取效率。 写入的时候，也可以利用DMA并行的写入，虽然浪费了一半的带宽。     RAID更多的设计空间  RAID-0: 不考虑备份，可以用两块1G的磁盘虚拟成一块2G的磁盘，并且相对一块2G的物理磁盘读写效率提升了一倍。 RAID-1: 就是上面所说的备份 RAID-10: 将上面两种组合起来，比如4块盘，先分别用两块构成RAID-1，然后在其基础上构成一个RAID-0 $v_0,v_1,v_2,v_3 \rightarrow A_0,B_0,C_0,D_0,E_0$，用多一块磁盘实现任意一块物理盘损坏的容忍和高效率，类似于奇偶校验。  $A,B,C,D$中对应存放$v_0,v_1,v_2,v_3$的值，而$E$中存放$v_0\oplus v_1 \oplus v_2 \oplus v_3$ 性能：随机读顺序读都是$80%$带宽，顺序写也是$80%$带宽(提前在内存中算好奇偶校验然后一起写)，随机写(单独写一块时，读取该块原来的数据和对应的校验磁盘中的对应数据)$P^\prime = P \oplus oldval \oplus newval$   性能瓶颈解决办法：将校验位P均匀分布到每一个磁盘中。      更可靠的存储 </description>
    </item>
    
    <item>
      <title>文件系统实现</title>
      <link>https://jarviszly.com/documents/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Wed, 24 Jun 2020 12:06:05 +0800</pubDate>
      
      <guid>https://jarviszly.com/documents/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/</guid>
      <description>分析  文件系统实现的本质回到了数据结构的设计上。 而数据结构课所学的都是讲的如何在内存上实现出各种数据结构。 内存在多级缓存的帮助下实现了随机访问，并且有多个内存管理的API 而对于磁盘来说，其不能随机访问任意一个bit，而是按照块为单位进行读写，所以每一个bit的访问不是O(1)的，没有malloc等函数的支持，只有read_blk,write_blk. 设计需求：一个树状的结构。 如果只考虑存储文件，一个虚拟磁盘可能对应多个物理磁盘上的块，而这些块不一定是连续的，所以很自然地想到使用链表。 链表有两种方式：  指针和数据放在同一个块中。  优点：不需要额外分配存放指针的空间 缺点: 数据的大小不是2的幂次(因为有一部分是指针)，在lseek的时候就不能使用移位操作来进行。   单独分配几个块存放所有的指针。  优点：局部性好，lseek更快 缺点：集中存放一旦损坏损失大     目录的实现：目录也是一个文件，只不过是在该文件中实现了一个目录的数据结构比如key-value mapping, 通过tag标记让文件系统访问该文件时按照目录的方式。  FAT(File Allocation Table)  采取的是集中存放指针的方法，使用备份的方式来降低损坏造成巨大损失的风险。 在FAT中，将多个块(512B)看作一个cluster，然后以cluster为单位来管理文件。   其中每一个表项  0：未分配 ffffff7: bad cluster(这个cluster损坏) ffffff8-ffffffe,-1：EOF 2&amp;hellip;: 已分配且是下一个块的编号    性能与可靠性  性能  FAT对于小文件来说十分合适 对于大文件来说不理想，因为如果要读取大文件最后一个bit，那么还是得遍历该文件。   可靠性  维护多个备份防止元数据损坏造成额外的开销    ext2/Unix文件系统  和FAT不同的是需要支持链接，所以其树状结构中的节点都是指针。 更关键的是该文件系统提供对大文件的高效的随机访问，设计者在其元数据中使用了类似页表的方式来完成索引。   目录结构：inode编号 + 该项长度 + name长度 + 文件类型 + 4字节对齐的name  性能和可靠性  大文件随机读写性能提高，小文件读写性能同样很好。 但同样和FAT具有存储可靠性的问题。  </description>
    </item>
    
    <item>
      <title>文件系统API</title>
      <link>https://jarviszly.com/documents/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9Fapi/</link>
      <pubDate>Tue, 23 Jun 2020 22:16:46 +0800</pubDate>
      
      <guid>https://jarviszly.com/documents/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9Fapi/</guid>
      <description>为什么需要文件系统  应用程序直接通过设备驱动程序访问存储设备不合适  多个应用程序并发访问存储设备 一个有Bug的应用程序可能直接损坏整个存储设备。   所以需要在这个基础上再添加一层抽象层，将一个磁盘抽象成多个虚拟磁盘。 文件系统就是对存储设备的虚拟化。  磁盘(I/O设备)是一个可读可写的字节序列 虚拟磁盘是一个动态的可读可写的字节序列   从实现方面来看，文件系统就是在持久化存储设备上的数据结构。  规定了数据的存储方式 提供了对数据结构进行的一些操作    文件API lseek, mmap, ftruncate  mmap  open一个文件后可以使用mmap(MAP_SHARED)将文件映射到地址空间，使用mmap(MAP_PRIVATE)创建一个文件的copy-on-write的副本   问题在于：如果我们使用mmap映射的长度超过文件大小，然后访问了超过文件大小的内容，会发生什么 mmap手册已经说明：会返回一个SIGBUS的信号 ftruncate可以改变一个文件的大小，lseek可以改变读写文件偏移量，那么这三个API可能会相互影响。  比如 mmap 2MB, lseek 3MB, ftruncate 1MB 那么之后读写在哪里？    偏移量管理  从上面一个例子可以知道偏移量管理十分重要。  当进程fork的时候，对于文件描述符是浅拷贝，也就是说父子进程共享一个偏移量。 当使用dup的时候，对于文件描述符也是浅拷贝。 使用open的时候，获得一个独立的offset.    文件系统API-管理众多虚拟磁盘 目录管理  mkdir, rmdir  硬链接和软链接  硬链接  需求：有的时候需要一个文件被多个目录引用，但不像要不必要的拷贝 ln filename newfilename 只允许文件对文件的硬链接，不允许目录的硬链接也不允许跨文件系统的硬链接。 而实际上对于Linux的文件系统来说，其树状结构的每一个叶节点并不是想FAT文件系统一样就是一个文件，而是一个指向某个虚拟磁盘的指针，于是，维护好每个虚拟磁盘的引用计数就能很好地实现硬链接，查看rm的系统调用可以发现使用的是unlink.</description>
    </item>
    
    <item>
      <title>设备驱动</title>
      <link>https://jarviszly.com/documents/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/</link>
      <pubDate>Tue, 23 Jun 2020 12:07:06 +0800</pubDate>
      
      <guid>https://jarviszly.com/documents/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/</guid>
      <description>I/O设备的抽象  cpu使用指令访问设备寄存器/设备存储。 在此意义上，很多东西都属于I/O设备，比如PIC,总线,DMA等。 而对于应用程序  应用程序具有访问I/O设备有需求 应用程序直接访问I/O设备是不现实的  I/O设备多样，应用程序难以写出portable的代码 不同应用之间需要同步协调各个I/O资源的使用     所以操作系统应该对I/O设备进行一定的抽象。 需求分析  printf: 希望向设备写入一些数据，所以需要write功能 浏览器：希望从某个TCP连接中读取数据，所以需要read功能 &amp;hellip;   所以分析可能需要的API为  read: 读出数据 write: 写入数据 ioctl: 读取/更改设备状态   操作系统建立一个新的抽象层，将不同的I/O设备抽象成为系统中可读可写&amp;hellip;的对象。 这样就能用同一个接口去访问不同的I/O设备，实现接口的代码就是设备驱动程序  设备驱动程序  设备驱动程序就是硬件抽象层的实现。 因为硬件抽象层使得应用程序看不到实际上的I/O设备，所以其实可以创造一些虚拟的，实际上不存在的设备。  如/dev/zero, /dev/null, /dev/urandom   在Linux系统中，everything is a file, 所以其设备驱动也就是文件所需要的一些操作。  特殊的设备-磁盘和网卡  磁盘的特性  以数据块为单位访问 使用DMA传输数据 应用程序一般不会直接访问，而是由文件系统访问。 大量的并发访问   网卡  超高速设备 &amp;hellip;   所以针对这两个设备，linux使用了另外的单独的抽象。  </description>
    </item>
    
    <item>
      <title>信号和jobcontrol</title>
      <link>https://jarviszly.com/documents/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%BF%A1%E5%8F%B7%E5%92%8Cjobcontrol/</link>
      <pubDate>Sun, 21 Jun 2020 20:59:55 +0800</pubDate>
      
      <guid>https://jarviszly.com/documents/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%BF%A1%E5%8F%B7%E5%92%8Cjobcontrol/</guid>
      <description>信号机制  想要实现ctrl+c使得进程退出，如何实现？  谁收到了ctrl+c这个东西?  如果在shell中运行一个cat, 然后ctrl+c会发现cat退出  此时shell在wait等待cat执行完返回，所以其不是收到处理ctrl+c的地方 cat此时正在执行read系统调用等待用户的输入，所以也不是。   实际上是操作系统的对象终端，其收到ctrl+c后会给cat进程发送一个SIGINT的信号。那么怎么样实现信号机制，使得无论该进程在干什么，都能被通知。  信号机制的实现  这样的需求可以联想到ICS中提到的硬件的中断机制，将硬件上的中断机制搬到进程上来当作信号机制。 假设cat进程在cpu上运行，当tty收到一个ctrl+c，操作系统会等到该cpu上一个中断到来，此时cat进程的所有信息(寄存器现场，内存)都被保存到了他的栈上实际上也在物理内存中，所以操作系统可以去修改这部分内存，在其间插入跳转到Signal处理的代码去执行，于是该进程就一定能够被通知。 在linux中提供了一些API，比如c语言中的signal可以注册一个处理某个信号的函数，这样就能够捕获到系统中的信号，从而做出不同的行为。  job control  如果一个进程中fork了很多个进程，那么在这个进程执行的时候，如果ctrl+c，那么应该是要所有fork的进程都要退出。 但是，如果这样，那么在shell上执行的所有进程都是通过shell进程fork出来的，那么此时ctrl+c，岂不是所有的进程都被杀死，所以这样简单的设计显然是不够的，应该将这些进程分组管理。 而实际上，在linux系统中，当一个shell启动后就会构成一个session结构，而session结构有一个control terminal和若干进程组。  进程组中的进程具有不同进程号，但是具有相同的进程组号，fork子进程会继承父进程的pgid，而execve不会改变pgid. shell每次fork出新进程都会为其创造一个独立的进程组。 在一个session中，任意时刻，都只能有一个位于前台的进程组。 信号会发送给前台进程组中所有的进程。 man 8 setpgid    </description>
    </item>
    
    <item>
      <title>终端和shell 应用眼中的OS</title>
      <link>https://jarviszly.com/documents/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BB%88%E7%AB%AF%E5%92%8Cshell-%E5%BA%94%E7%94%A8%E7%9C%BC%E4%B8%AD%E7%9A%84os/</link>
      <pubDate>Fri, 19 Jun 2020 22:05:47 +0800</pubDate>
      
      <guid>https://jarviszly.com/documents/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BB%88%E7%AB%AF%E5%92%8Cshell-%E5%BA%94%E7%94%A8%E7%9C%BC%E4%B8%AD%E7%9A%84os/</guid>
      <description>终端  终端是操作系统中的一个对象,也是一个I/O设备。 在Unix看来，终端也是一个文件(everything is a file)  ANSI Escape Codes  终端支持Escape Codes，通过这些Codes可以完成屏幕清除/滚动，设置颜色等。 如果用cat输出某些二进制文件之后，可能会发生一些神奇的事情，比如光标没了之类的，这是因为可能该二进制文件中正好有一个负责控制光标的Escape Code，然后其在终端中输入就执行了。 可以用reset来还原终端  终端的模式  默认是cooked mode, 也就是终端自带一个行编辑器，按下回车才去执行这一行的命令 还有一个raw mode，按键就返回。  向终端输出  使用ls &amp;ndash;color等变体发现  ls &amp;ndash;color : 显示颜色，输出在一行 ls &amp;ndash;color | less : 不显示颜色(只显示ESC序列)并在多行输出。   那么发生了为什么？ 使用strace 和 lstrace 康康不同层面干了什么吧 查看ltrace可以发现，都调用了一个isatty()函数，用来判断标准输出是不是终端，然后自适应输出。 查看strace可以发现isatty()会调用一个系统调用ioctl().  Shell  操作系统 = 对象 + API, 那么用户怎么调用API? shell是一门编程语言.  interactive shell: 收到一行执行一行  env | grep PS1   non-interactive shell: 就是普通的语言解释器  bash -c &amp;lsquo;env&amp;rsquo; | grep PS1     shell是人机接口,interactive shell将用户给I/O设备的指令翻译成了系统调用的序列, 也就是说shell是用户眼中的操作系统(I/O设备)和应用眼中的操作系统(syscall)的桥梁。 shell正如其名，它是操作系统内核对外的一个外壳，外界将需要传达的shell，shell则翻译成一系列系统调用然后传达给内核。 shell的分类：CLI/GUI  shell的实现  shell的实现中有两个最基本的功能：向操作系统的某个对象读和写，比如cat命令，通过strace可以发现调用了read和write两个系统调用，这两个系统调用都是向文件描述符里读或写，那么什么是文件描述符 文件描述符： 是一个指向操作系统中某个对象的指针，是进程(状态机)的一部分，所以在fork的时候也会被拷贝。  shell中的重定向 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  echo Hello World &amp;gt; a.</description>
    </item>
    
    <item>
      <title>DemandPaging</title>
      <link>https://jarviszly.com/documents/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/demandpaging/</link>
      <pubDate>Wed, 17 Jun 2020 11:04:30 +0800</pubDate>
      
      <guid>https://jarviszly.com/documents/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/demandpaging/</guid>
      <description>Demand Paging(按需求分配页面)  mmap实际上只是做了一些标记，并没有实际上的分配物理内存，所以mmap的速度很快。 实际上，在execve重置进程的时候，此时只需要  在物理内存中分配一个页面给该进程的cr3. 修改进程对应的映射函数或者说映射数据结构(cr3), 使得进程虚拟地址空间中的内核代码和物理内存中的os代码建立映射。 在操作系统的数据中必然存在一个数据结构来表示该进程，如下 1 2 3 4 5 6 7 8 9  struct mm_area{ _Area range; //内存映射的区间  int prot, flags, fd, offset;//映射的属性  struct page* pages; //用于遍历该映射中所有的页面。 } struct task{ struct mm_area areas[16]; ... }   只需要在加载时设置好这些$mm_area$,就可以。
 然后将$rip$置为$ELF~entry$(静态链接)或者 $lib.so$(动态链接)执行即可。 当发生缺页情况或者dereference nullptr时，cr2寄存器中会保留发生异常的地址，然后根据这些信息到$tas$k的$mm_area$去查询有没有匹配的，如果没有匹配则出现异常，否则根据$mm_area$中信息从磁盘中读取数据到物理内存中。    Swap  Demand paging的另一个用途就是其反方向。 一个进程已经分配了页面，但我们可以主动将该页面swap out,保存到磁盘中，然后使用原来该页面的物理内存，当又需要该部分数据时，又swap in. LRU是较好的Swap策略。  Shared Objects 和 外部符号   动态链接库采用GOT表格，而如果修改对应的GOT表项，比如将printf对应的表项的地址改为自己写的printf_wrapper的地址，那么当我们调用printf时就会去执行printf_wrapper，而我们在printf_wrapper中同样可以去调用printf函数，并且在之前打印一些log，这样我们就得到了ltrace</description>
    </item>
    
    <item>
      <title>处理器调度</title>
      <link>https://jarviszly.com/documents/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%A4%84%E7%90%86%E5%99%A8%E8%B0%83%E5%BA%A6/</link>
      <pubDate>Tue, 16 Jun 2020 14:19:05 +0800</pubDate>
      
      <guid>https://jarviszly.com/documents/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%A4%84%E7%90%86%E5%99%A8%E8%B0%83%E5%BA%A6/</guid>
      <description>单处理器分时调度 Round-Robin调度方法  将时间划分成一个个时间片，每个进程轮流获取一个时间片的CPU。 但是不同进程对cpu的需求是不一样的，一个极端的例子就是10个进程，有9个是死循环，还有一个vim进程，如果此时使用Round-Robin算法，则会导致vim进程获取输入缓慢，所以我们需要给不同进程设置优先级。  优先级  Unix nicess  nice属性的值的范围在-20~19，其中-20意味着极坏，19意味着极好，越坏的进程越容易获得cpu。   如果使用Round-Robin的形式，如何划分优先级  在圆上根据nice值，按照一定比例划分进程对应的圆弧，然后一个指针在圆上旋转，指针指到哪个进程部分，就执行哪个进程。    多级反馈调度  在系统中存在多个Round-Robin调度器，每个调度器对应一个优先级，优先级高的先调度，只有优先级高的都暂时不需要cpu时，才可以调度低优先级的。  Linux调度器-CFS(完全公平调度)  每个进程都有一个vruntime属性记录该进程到目前为止在cpu上的虚拟运行时间，每次需要切换进程时都选择补偿虚拟运行时间最短的那个。 如果一个进程创建子进程，则其子进程会继承父进程的vruntime  一些小问题  问题1：如果一个进程沉睡了较长时间，那么被唤醒后一段长时间都是该进程占据cpu 解决办法：唤醒进程时给进程的$vruntime = max(vruntime, min(vruntime_{others}))$,这样就能保证其既能很快获得调度又不会长时间占据cpu。 问题2：优先级如何表示 解决办法：进程的vruntime实际上就是根据优先级来使用不同权重计算的，对于坏的进程，可能其一个vruntime就能获得多个时间片，而对于好的进程，可能一个vruntime只能获得1个或少量的时间片。 问题3：用什么数据结构实现vruntime 解决办法：linux中复用了红黑树。 问题四：用64位无符号整数表示vruntime,其运行500多年会发生溢出问题，如何解决 解决办法：Linux内部使用的是两个vruntime之间的$\Delta$来确定两个进程谁应该被调度。  其假设不会有进程沉睡很长很长时间，所以系统中的所有进程的vruntime相差不会很大(假设不会超过u64的一半)。 1 2 3 4 5 6 7 8  s64 delta = (s64)(a-&amp;gt;vruntime - b-&amp;gt;vruntime); //如果delta &amp;lt; 0, 则说明应该调度a. //否则应该调度b.  /* 如果a溢出了那么在数值上a-&amp;gt;vruntime远小于 * b-&amp;gt;vruntime，但是两者的差转换为带符号64位整 * 数后就会变为正数。 */       优先级翻转   实际上当考虑到互斥同步的情况后，会给某些调度方法带来一些问题：</description>
    </item>
    
    <item>
      <title>动态链接</title>
      <link>https://jarviszly.com/documents/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/</link>
      <pubDate>Mon, 15 Jun 2020 23:05:37 +0800</pubDate>
      
      <guid>https://jarviszly.com/documents/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/</guid>
      <description>静态链接  为了一个程序不同部分的解耦，可以将一个程序分成若干个文件是十分必要的，那么不同的文件最终怎么变成一个可执行文件加载到操作系统上执行的。  1 2 3 4 5 6 7 8 9 10 11 12 13 14  //a.c int foo(int a, int b){ return a + b; } //b.c int x = 100, y = 200; //main.c extern int x,y; int foo(int a,int b); int main(){ printf(&amp;#34;%d + %d = %d\n&amp;#34;,x,y,foo(x,y)); }     不同的文件通过编译形成不同的$.o$文件，查看$main.o$可以发现，其对$x,y,foo$的使用，都使用$0(%rip)$代替($rip$寻址，但偏移量不知)。
  在静态链接的之后，就会根据ELF文件头信息，正确地填入偏移量，ELF文件中都是符号地址-4，是因为此时rip指向的是下一条指令，其相对于所需填入的地方增加了4个字节($0(%rip)$中的0占4字节)。
  静态ELF加载器：
 在加载静态链接得到的可执行文件时，直接根据ELF程序头表中信息使用mmap将文件中对应部分映射到地址空间中即可。    动态链接  如果都是用静态链接太耗费资源。  需求1  所需动态链接的库只含有代码。 实现：直接使用mmap将这部分映射到对应程序的地址空间，这样也保证了在物理内存中只有一个该库函数的备份。 实现前提：代码需要是位置无关代码，引用跳转使用(PC相对寻址)。  需求2  所需动态链接的库含有本库使用的代码和数据。 实现：同样只需要mmap，因为数据也可以根据数据和PC的Offset来相对寻址。  需求3  在一个动态链接库中可以使用其他动态链接库的符号。 实现：使用表来记录相应的函数的地址。比如在foo中调用bar，动态链接器先加载bar所在的库，然后加载foo时，就将bar所在的地址填入表格中。  Linux中的动态链接-GOT和PLT   linux中动态链接同样使用了需求3类似的理念，用表格来记录地址，一个程序有一个GOT表，其结构如下：</description>
    </item>
    
    <item>
      <title>进程抽象</title>
      <link>https://jarviszly.com/documents/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E6%8A%BD%E8%B1%A1/</link>
      <pubDate>Mon, 15 Jun 2020 12:30:41 +0800</pubDate>
      
      <guid>https://jarviszly.com/documents/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E6%8A%BD%E8%B1%A1/</guid>
      <description>回顾操作系统   在应用程序看来操作系统就是一组系统调用。
  在底层硬件看来操作系统就是一个C程序，一个状态机。
  操作系统是对进程状态机的模拟，这种模拟就是所谓的虚拟化，进程认为自己独占cpu。
  操作系统中常见API
 进程(状态机)管理  fork: 拷贝一份当前的进程(包括内存，寄存器现场，操作系统的对象，libc中缓冲区等等)。 execve: 替换当前进程为另一个进程，从头执行。 exit: 退出当前进程。   存储(地址空间)管理  mmap: 地址空间和物理内存之间的映射。 brk: 虚拟地址空间管理   文件(数据对象)管理  open,close: 文件访问管理 read,write: 数据管理 mkdir, link, unlink: 目录管理      进程抽象-fork,execve,exit fork  复制一个一摸一样的进程出来，一个返回子进程pid，子进程则返回0。  1 2 3 4 5 6  #define N 2 for(int i = 0; i &amp;lt; N; ++i){ fork(); printf(&amp;#34;hello,world.</description>
    </item>
    
    <item>
      <title>虚存,Linux进程地址空间</title>
      <link>https://jarviszly.com/documents/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%99%9A%E5%AD%98linux%E8%BF%9B%E7%A8%8B%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/</link>
      <pubDate>Thu, 11 Jun 2020 22:51:05 +0800</pubDate>
      
      <guid>https://jarviszly.com/documents/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%99%9A%E5%AD%98linux%E8%BF%9B%E7%A8%8B%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/</guid>
      <description>Linux进程的地址空间  进程的地址空间如何创建，创建之后如何修改？  1 2 3 4 5 6 7  //映射 void* mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset); int munmap(void *addr, size_t length); //修改映射权限 int mprotect(void *addr, size_t length, int prot);     看mmap手册可以知道其作用是可以将某个文件中的一部分映射到内存中一部分，所以很容易可以想到在进程地址空间创建时，需要将进程的代码和数据搬到地址空间，所以可以用mmap来当作加载器。
  那么mmap又是如何实现的，通过strace观察mmap可以发现，其使用了/proc/proc_id/maps文件中的信息，这个文件中记录了该进程的所有内容在文件和地址空间间的映射关系。
  通过cat查看/proc/proc_id/maps的内容，可以发现进程的地址空间为
     动态链接库在heap和stack之间
  而在地址空间最后三个部分，发现了三个神秘的东西(vvar,vdso,vsyscall)
 vvar: 内核和进程共享的数据 vdso: 系统调用的代码实现，这些系统调用不需要陷入内核执行。(比如time，getcpu等) vsyscall: 以前的系统调用的代码实现，但因为安全问题，已经不再使用，为了向后兼容而保留。    虚拟存储-分页机制  为了实现mmap这样的映射机制，硬件给予的支持就是虚拟存储-分页机制。 而分页机制最本质的问题就是找一个合适的数据结构来表示虚拟地址到物理地址的映射关系，已经将虚拟地址和物理地址以页为单位划分，则需要表示$2^{20}$到$2^{20}$的映射关系。 使用数组是第一个很直观的想法，但是数组开销太大，无法忍受。 使用radix-tree(基数树)  在32位机器中，设定一页为4KB，一个指针为4B，所以一页可以存放1024个指针，所以一页可以表示10位，每一个指针又指向这样一个页面，于是两级表示了20位，在第二级结点中，每个指针直接指向一个实际的页面，于是总共表示了32位。 在64位机器中，用了4级表示了48位，实际上64位机器其物理地址为48位。    </description>
    </item>
    
    <item>
      <title>同步{条件变量，信号量，生产者消费者问题，哲学家吃饭问题}</title>
      <link>https://jarviszly.com/documents/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%90%8C%E6%AD%A5%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%90%83%E9%A5%AD%E9%97%AE%E9%A2%98/</link>
      <pubDate>Tue, 09 Jun 2020 22:29:06 +0800</pubDate>
      
      <guid>https://jarviszly.com/documents/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%90%8C%E6%AD%A5%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%90%83%E9%A5%AD%E9%97%AE%E9%A2%98/</guid>
      <description>同步  两个(或多个)线程在一定时间内保持一定的关联。 直白的来说：  互斥：各个线程单独完成自己的事情。 同步：多个线程协作完成一件事情，所以在某些时候线程之间需要知道彼此的状态。    实现同步 条件变量(极其重要)  同步的本质: 当一个条件满足时，线程继续执行，否则等待。 则用一个条件变量(对象)对应表示该条件。  当条件不满足时，在该对象处等待。 当一个线程发现某个条件满足时，唤醒该条件变量对应的线程(一个或者所有)   条件变量API  1 2 3  wait(&amp;amp;cv); //在cv条件变量处等在。 signal(&amp;amp;cv)/notify(&amp;amp;cv); //唤醒一个cv条件变量对应线程。 broadcast(&amp;amp;cv)/notifyall(&amp;amp;cv); //唤醒cv条件变量对应的所有线程。    在使用条件变量时，常常需要使用某个变量来表示条件，而该变量是所有线程共享的，所以在访问时需要使用锁(互斥锁)来保护，所以条件变量搭配互斥锁一起完成同步  1 2 3 4 5 6 7  mutex_lock(&amp;amp;mutex); // do some things wait(&amp;amp;cv,&amp;amp;mutex); //在wait中会先释放掉该互斥锁，再等待，被唤醒时会先尝试重新获得该互斥锁。 // do some things mutex_unlock(&amp;amp;mutex); //signal不需要用mutexlock保护    需要注意的是使用条件变量是一定一个条件对应一个条件变量。  信号量  信号量 = 带计数条件变量(相当于条件变量和控制条件的变量综合) + 互斥锁。 通俗理解：将信号量看作更衣室的手环，拿到手环才可以进入更衣室否则等待。 当手环数量为1时，信号量的作用和互斥锁一致。 信号量API  1 2  P(&amp;amp;semv); //申请一个手环，如果拿到就返回否则等待。 V(&amp;amp;semv); //用户生成一个手环，交给等待用户或者管理者。   经典同步问题 生产者消费者问题   问题描述：</description>
    </item>
    
    <item>
      <title>并发数据结构malloc Free算法</title>
      <link>https://jarviszly.com/documents/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B9%B6%E5%8F%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84malloc-free%E7%AE%97%E6%B3%95/</link>
      <pubDate>Sat, 30 May 2020 21:37:09 +0800</pubDate>
      
      <guid>https://jarviszly.com/documents/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B9%B6%E5%8F%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84malloc-free%E7%AE%97%E6%B3%95/</guid>
      <description>并发数据结构-并发链表  在要使用很多次链表的场合，定义链表头时应该直接定义为一个链表结点，而不是一个指针。  当链表头是一个指针时，在操作时就需要考虑指针是否为空的情况。 当链表头是一个结点时，就不需要考虑这个情况，此时链表头不存储任何数据 。    </description>
    </item>
    
    <item>
      <title>操作系统中的互斥</title>
      <link>https://jarviszly.com/documents/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E4%BA%92%E6%96%A5/</link>
      <pubDate>Sat, 30 May 2020 20:56:25 +0800</pubDate>
      
      <guid>https://jarviszly.com/documents/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E4%BA%92%E6%96%A5/</guid>
      <description>操作系统上的互斥(多处理器多线程) 1 2 3 4 5 6 7  void func(void* arg){ while(1){ lock(&amp;amp;biglock); printf(&amp;#34;Thread-%s on CPU #%d acuquired the lock\n&amp;#34;,arg,_cpu()); unlock(&amp;amp;biglock); } }    上述代码在多处理器上多线程运行时会发现一段时间后，总是一个线程在一个处理器上获得锁。safety和liveness都没问题而,fairness出现了问题。 使用状态机来理解发现：对于持有了锁的线程，其中断大概率出现在printf，而此时其他CPU上的其他线程都处于自旋状态，结果绕一圈回到自己继续执行。 这说明：获得自选锁的线程(处理器)不应该被中断，否则会因为其他线程的自旋浪费时间，所以可以在lock函数中加入关中断，在unlock中加入开中断  1 2 3 4 5 6 7 8 9  void spin_lock(spinlock_t &amp;amp;lk){ cli(); while(atomic_xchg(&amp;amp;lk-&amp;gt;locked,1)); } void spin_unlock(spinlock_t &amp;amp;lk){ atomic_xchg(&amp;amp;lk-&amp;gt;locked,0); sti(); }    而上述代码又面临一个问题，如果一个线程多次获得不同的锁，之后又依次释放锁，则结果第一次释放锁就导致开中断，因此需要保存第一次获得锁的时候线程(CPU)中断状态，在最后一次释放锁的时候还原状态。 所以需要在CPU的结构中加上记录当前CPU关中断计数以及首次关中断时 %eflags &amp;amp; FL_IF的值  互斥锁  自旋锁由于可能导致浪费很多资源，所以其只适用于很短并且希望能立即执行的临界区。而有的时候，只有互斥的需求但不介意被打断或者自身等待。 比如在读写磁盘时，此时如果使用自旋锁，会导致浪费很多时间，并且在这段时间内可能有很多中断，但由于关中断的原因无法到达CPU. 互斥锁的需求分析  持有锁的线程  允许处理器相应中断。 允许切换到其他线程。   等待锁的线程  不要占用处理器资源自旋。     一个很简单的想法就是当我发现自身无法得到锁，需要自旋时就让另一个线程执行。  1 2 3 4 5  void mutex_lock(mutexlock_t &amp;amp;lk){ while(atomic_xchg(&amp;amp;lk-&amp;gt;locked, 1)){ let_another_thread_to_execute(); } }    上述方法值得优化的点在于：可能等待锁的线程有很多，前面需要空转很多线程(每个线程都会atomic_xchg)才能让真正可以执行的线程执行。 所以可以加上一个调度者，每当线程无法获得锁时就直接放弃对CPU的占有，陷入等待，等待调度者的调度。 添加一个等待队列这样的并发数据结构，由调度者控制  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  void mutex_lock(mutexlock_t &amp;amp;lk){ int acquired = 0; spin_lock(&amp;amp;lk-&amp;gt;spinlock);//保护等待队列  if(lk-&amp;gt;locked !</description>
    </item>
    
    <item>
      <title>硬件初始化与操作系统加载</title>
      <link>https://jarviszly.com/documents/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%A1%AC%E4%BB%B6%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8A%A0%E8%BD%BD/</link>
      <pubDate>Wed, 20 May 2020 21:52:55 +0800</pubDate>
      
      <guid>https://jarviszly.com/documents/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%A1%AC%E4%BB%B6%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8A%A0%E8%BD%BD/</guid>
      <description>硬件初始化   硬件和软件之前存在一定的约束
 CPU reset后其处于一个确定的状态，其PC指针一般指向一段ROM,而这个ROM中存储了硬件厂商提供了firmware(固件) 此时处理器大部分特性都是关闭的比如缓存，虚存    Firmware(BIOS, UEFI)
 将用户数据加载到内存  存储介质上的二级loader(比如x86) 直接加载操作系统(嵌入式系统)      Legacy BIOS的约定
 会把引导盘的第一个扇区(512B)加载到内存，然后跳转到这部分执行    操作系统的加载   BIOS加载的512字节中包含了
 16bit $\rightarrow$ 32bit ELF32/64的通用loader    执行完16位向32位的转换后，会跳转到通用loader上执行，该通用loader默认引导盘的存储形式为    所以该loader会先将main函数的参数加载到内存，然后接着加载剩余ELF文件的第一页(4KB),然后根据第一页中ELF文件头的信息，加载剩余所需要的部分，完成ELF文件加载，就跳转到该ELF文件的入口处执行
  ELF文件开始就是从32位模式，转为64位模式，然后建立页表，设置段寄存器，完成初始化，跳转执行。
  跳转执行后，会完成很多cpu的初始化，然后切换堆栈，跳转去执行main.
  </description>
    </item>
    
    <item>
      <title>线程的互斥</title>
      <link>https://jarviszly.com/documents/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BA%92%E6%96%A5/</link>
      <pubDate>Sat, 16 May 2020 23:23:18 +0800</pubDate>
      
      <guid>https://jarviszly.com/documents/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BA%92%E6%96%A5/</guid>
      <description>在现代处理器上Peterson算法的问题  Peterson算法中的，x = 1; turn = T2; 在处理器上会变成指令store(x, 1) store(turn, T2).而因为store指令都比较耗费时间，所以在现代处理器的优化下，处理器会指令后面的指令从而导致两个线程都进入临界区。 很大的问题在于在计算机世界中，我们无法同时&amp;quot;看&amp;quot;和&amp;quot;做&amp;quot;即不能同时load 和 store.  共享内存带来更多的问题  由于不能同时load和store所以当线程共享内存时，会引发其他问题，比如多线程求sum. 四个线程求和放入同一个变量，加法对应的指令只有一条add，如果按照状态机的假设，每次只执行一条指令且指令是原子性的，那么答案应该正确。 而实际上，一条add指令可以被看成三条更小的指令：load, ++, store.而这三条指令之间的原子性等没有得到保证，所以出现错误。  x86的解决方法-增加原子性操作  x86架构提供了一些原子性操作来使得软件能够完成锁的实现，比如 lock add(一条原子性的add指令)，xchg(一条原子性的交换内存和变量的值的指令)等。 使用xchg指令可以很简单地实现自旋锁  1 2 3 4 5 6 7 8 9  int table = key; void lock(){ while(1){ int got = xchg(&amp;amp;table,NOTE); if(got == key) break; } } void unlock(){ xchg(&amp;amp;table,key);   RISC-V和Mips的解决办法-提供满足原子性的load和store  LoadReserved/Store-Conditional(LR/SC)  LR: 正常的读取某一个变量，并在相应变量上标记哪个线程所标记。 SC: 储存之前，检查标记是否对应，如果对应则正常存储，否则重做之前的指令。   LR/SC  实际上就是当LR和SC之间的操作都没有被破坏原子性等，自然这些指令就保证了原子性。  数据竞争  并不是加上了锁就能保证多线程的正确运行，比如两个线程用两把锁对同一个变量修改。 实质是 当有两个线程有两个操作访问同一段内存，且这两个操作之间没有原子性的指令(也就是不能保证两个操作执行的顺序)，就会出现数据竞争。 解决办法：对于多线程共享的内存用同一把锁。  </description>
    </item>
    
    <item>
      <title>状态机模型理解程序执行</title>
      <link>https://jarviszly.com/documents/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%8A%B6%E6%80%81%E6%9C%BA%E6%A8%A1%E5%9E%8B%E7%90%86%E8%A7%A3%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C/</link>
      <pubDate>Thu, 14 May 2020 20:30:58 +0800</pubDate>
      
      <guid>https://jarviszly.com/documents/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%8A%B6%E6%80%81%E6%9C%BA%E6%A8%A1%E5%9E%8B%E7%90%86%E8%A7%A3%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C/</guid>
      <description>单线程程序的状态机模型  不同内存和寄存器状态对应了状态机的不同节点。 大部分状态s有唯一的后继状态，存在一些指令，其有后续状态，如rdtsc(获取处理器时间戳)，rdrand(真随机数),syscall(系统调用) 状态机模型是一种理解程序和分析程序的工具  模型的应用 Time travel debugging  程序运行都是从初始结点向后跳转，那么能否从前往后？ 如果能把状态全部记下来是不合理的，但是一条指令只改变很少的寄存器和内存，所以只需要记录两个状态之间的diff就行。 gdb  target record-full 开始记录(此是需要程序已经开始执行) record stop 结束记录 reverse-step(rs)/reverse-stepi(rsi) 向前跳转    Record and Replay  记录程序执行的信息，重现某次程序执行结果。 对于确定性的指令，只需要记录下开始位置和执行了多少条指令。 对于不确定性的指令，则需要记录额外的信息，比如read系统调用，需要记录read的返回值，其读入的具体数据等。  多线程(并发)程序的状态机模型  确定了每一个线程的寄存器状态和共享内存的状态就唯一确定了一个状态机状态，多线程程序的状态机模型本身一个状态的后继状态就是多样的。 因为多线程状态机状态太多了，所以之前的应用需要重新设计。  Peterson算法：实现2个线程的互斥  两个人(P1,P2)分别有一个棋子(F1,F2)并分别可以向卫生间门上的板子上写上对方的名字。 代码如下  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  //假设及其每次原子地执行每一行代码，内存访问立即可见 int f1 = 0, f2 = 0;//棋子 int turn = P1;//厕所上的牌子 void thread_1(){ f1 = 1;//举起自己的棋子  turn = P2;//优先让别人先去  while(f2 &amp;amp;&amp;amp; turn == P2); //对方举了棋子并且还未去  //临界区  f1 = 0;//放下棋子 } void thread_2(){ f2 = 1; turn = P1; while(f1 &amp;amp;&amp;amp; turn == P1); f2 = 0; }    可以枚举出这两个线程执行顺序的所有可能来证明该算法的正确性。  </description>
    </item>
    
    <item>
      <title>并发编程</title>
      <link>https://jarviszly.com/documents/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</link>
      <pubDate>Sun, 10 May 2020 21:48:04 +0800</pubDate>
      
      <guid>https://jarviszly.com/documents/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</guid>
      <description>并发编程 并发和并行  并发(Concurrent): 多个执行流可以不按照一定的顺序执行 并行(Parallel): 多个执行流可以同时执行(多个处理器)  线程共享  线程之间共享所有代码和全局变量。 每个线程拥有自己的堆栈，独享寄存器。  C语言多线程编程之入门  POSIX Threads, man 7 pthreads, 需要gcc -lpthread gcc -I 选项增加include path(效果等价于 #include &amp;ldquo;&amp;quot;)  多线程编程之放弃 放弃原子性  由于 中断/异常 的机制，导致一个线程的代码(指令)不会按照其顺序执行。 例子：山寨支付宝(有钱人的生活就是这般枯燥无味)  1 2 3 4 5 6 7 8 9  int money bool pay(int cost){ if(money &amp;gt;= cost){ money -= cost; return true; } else return false; }   放弃顺序性  由于 编译器的优化 指令的顺序可能和程序的顺序不一致。 例子：不同优化等级的for循环累加  1 2 3 4  #define n 100000int sum = 0; for(int i = 0; i &amp;lt; n; ++i) sum++;    可以使用objdump -d 查看不同优化等级下的汇编代码。  放弃可见性  由于 CPU 的加速，导致指令不一定按照其显示的顺序执行。 例子：两个线程分别对x，y赋值并打印  1 2 3 4 5 6 7 8 9 10 11  int x = 0, y = 0; void thread_1(){ [1] x = 1; [2] printf(&amp;#34;y = %d\n&amp;#34;,y); } void thread_2(){ [3] y = 1; [4] printf(&amp;#34;x = %d\n&amp;#34;,x); }      x y 概率 调度顺序     0 0 0.</description>
    </item>
    
    <item>
      <title>归一化 FLD 人脸识别</title>
      <link>https://jarviszly.com/documents/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB/%E5%BD%92%E4%B8%80%E5%8C%96-fld-%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/</link>
      <pubDate>Thu, 26 Mar 2020 08:02:36 +0800</pubDate>
      
      <guid>https://jarviszly.com/documents/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB/%E5%BD%92%E4%B8%80%E5%8C%96-fld-%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/</guid>
      <description>特征归一化(normalization) 每维度归一  很多时候，不同维度需要统一到同样的取值范围。 训练集$x_1,\cdots ,x_n$,$x_i = (x_{i1},\cdots,x_{id})$  对于每一维数据为$x_{1j},\cdots, x_{nj}$ 取其最小值和最大值$x_{min,j},x_{max,j}$ 对于该维度的任何数据$x_{ij} = \dfrac{x_{ij} - x_{min,j}}{x_{max,j} - x_{min,j}}$    稀疏数据  每一维度归一存在的问题  如果某一维度$max = min$即出现分母为0，此时说明该维度没有什么作用，直接删去。 是否可以统一到别的区间  如[-1,1]: $x_{ij} \leftarrow 2\times (\dfrac{x_{ij} - x_{min,j}}{x_{max,j}-x_{min,j}} - 0.5)$     稀疏数据(sparse data):数据中很多纬度值为0，这在归一化中会带来问题。 维度值为零有两种可能  该维度无意义(没有采样，对该任务无影响等)，设置为0 该维度的值为0   那么对于上面两种情况，在归一化时需要分开考虑  无意义情况：仍然设置为0 值为0的情况：按照正常的归一化    $l_2$或者$l_1$归一化  有的时候各个维度之间取值范围不同是有意义的，但是不同的数据点之间的大小(如向量长度)应保持一致，即对每一个数据点进行归一化 $l_2$归一化：对于数据$x_i = (x_{i1},\cdots,x_{id})$  $x_{ij} \leftarrow \dfrac{x_{ij}}{\Vert x_i \Vert_{l_2}},\qquad \Vert x_i \Vert_{l_2} = \sqrt{x_i^Tx_i}$   $l_1$归一化：适用于非负特征，对于数据$x_i = (x_{i1},\cdots,x_{id})$  如果数据是直方图，效果最佳 $x_{ij} \leftarrow \dfrac{x_{ij}}{\Vert x_i \Vert_{l_1}},\qquad \Vert x_i \Vert_{l_1} = \sum_{j=1}^d \vert x_{ij} \vert$    服从高斯分布的归一化  有时候可以确信每一个维度都是服从高斯分布 对于每一维j,数据为$x_{1j},\cdots,x_{nj}$  计算其均值$\hat{\mu}_j$和方差$\hat{\sigma}_j^2$ 对于每一个特征值$x_{ij}\leftarrow \dfrac{x_{ij} - \hat{\mu}_j}{\hat{\sigma}_j}$    归一化测试数据  在归一化测试数据的时候，我们不能像对待训练集一样，从中取得最大值最小值平均值之类的。 需要用训练集归一化时得到的归一化模型(比如参数$x_{max,j}$)，来归一化测试集。  Fisher线性判别分析(FLD)  PCA在数据是单个高斯分布是最佳的，其有利于表示数据，但是和分类无关 在分类问题中，不同类别的分布$p(\bm{x}\vert y=i)$不能相同，所以FLD用来提取利于分类的特征。    形式化表示(二类问题)  希望找到一个投影方向，使得被投影后，两个类别的数据容易被分开。 两个类的均值 $$\bm{\mu_1} = \dfrac{1}{N_1}\sum_{y_i = 1}\bm{x_i}, \bm{\mu_2} = \dfrac{1}{N_2}\sum_{y_i = 2}\bm{x_i}$$ 投影后均值为$\bm{m_1} = \bm{w}^T\bm{\mu_1},\quad \bm{m_2} = \bm{w}^T\bm{\mu_2}$ 描述分开的程度-Fisher准则  在要求$\vert \bm{m}_2 - \bm{m}_1 \vert$尽可能大的同时，要求两个在投影后尽可能集中(不分散).</description>
    </item>
    
    <item>
      <title>语法制导的翻译</title>
      <link>https://jarviszly.com/documents/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%E7%9A%84%E7%BF%BB%E8%AF%91/</link>
      <pubDate>Thu, 19 Mar 2020 10:23:12 +0800</pubDate>
      
      <guid>https://jarviszly.com/documents/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%E7%9A%84%E7%BF%BB%E8%AF%91/</guid>
      <description>语法制导定义和语法制导翻译  语法制导定义(SDD)  将文法符号和某些属性相关联，并通过语义规则来描述如何计算属性的值。 如$E\rightarrow E_1 + T\qquad E.code = E_1.code \Vert T.code \Vert &amp;lsquo;+&#39;$ 属性code表示表达式的逆波兰表达式(后缀表达式)。   语法制导翻译(SDT)  在产生式体中加入语义动作，并在适当的时候执行动作 如$E\rightarrow E_1 + T\qquad \{ print &amp;lsquo;+&amp;rsquo;;\}$    语法制导定义(SDD)  SDD(Syntax-Derected Definition)是上下文无关文法和属性/规则的结合  属性和文法符号相关联，规则和产生式相关联   对于文法符号$X$和属性$a$，我们用$X.a$表示分析树种某个标号为$X$的结点的值.  分析树和属性值     综合属性和继承属性  综合属性(Synthesized Attribute)  结点$N$的属性值由其产生式所关联的语义规则来定义 通过$N$的子结点或者$N$本身的属性值来定义   继承属性(Inherited Atrribute)  结点$N$的属性值由其父结点产生式所关联的语义规则来定义 依赖于$N$的父结点，$N$本身和$N$兄弟结点的属性值   约束  不允许$N$的继承属性通过其子结点上的属性来定义，但允许$N$的综合属性依赖于其自身的继承属性 终结符号只有综合属性    S属性的SDD  只包含综合属性的SDD称为S属性的SDD  每个语义规则都根据产生式体的属性值来计算头部的属性值   S属性的SDD可以和LR分析器一起实现 语义规则不应该有复杂的副作用  副作用不能影响其他属性的求值 没有副作用的SDD称为属性文法    语法分析树上的SDD求值  注释语法分析树：包含了各个结点的各个属性值的语法分析树，也叫标记语法分析树。 计算顺序  如果要计算某个结点的属性a为$f(N_1.</description>
    </item>
    
    <item>
      <title>主成分分析(PCA)</title>
      <link>https://jarviszly.com/documents/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB/pca/</link>
      <pubDate>Tue, 17 Mar 2020 15:21:33 +0800</pubDate>
      
      <guid>https://jarviszly.com/documents/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB/pca/</guid>
      <description>PCA基础 常见数据特点  数据各个维度之间不是相互独立的  数据的内在维度通常远低于其表面维度。 因此需要降低维度(dimensionality reduction),PCA在降维方法中(可能)是最常用的一种。    0阶表示  假设我们的数据实际上只有一个点，可能由于噪声的存在我们收集到的数据为$x_1,x_2,\cdots,x_n$.  当噪声不存在时$x_1 = x_2 = \cdots = x_n$   不允许使用任何维度，如何最佳表示这个数据点$x$  寻找某个固定的向量$m$使得(即到每个点的距离的平方和最小) $$J_1(m) = \mathop{min}\limits_m \sum_{i=1}^n \Vert x_i - m \Vert^2$$ 假设$m$是d维的，有n个数据，那么每个数据使用的维度: $\dfrac{d}{n} \mathop{=} \limits_{n \rightarrow 0} 0$   最优解(偏导等于0)： $$m^* = \mathop{argmin}\limits_m \sum_{i=1}^n \Vert x_i - m \Vert^2 = \dfrac{1}{n}\sum_{i=1}^n x_i = \bar{x}$$  一维表示：数据维度间的线性关系  数据是$d$维的，但是内在维度可能是$m(\ll d)$维的，PCA用线性来降低维度。 $y = w^T x + b\qquad (x\in \reals^d, y\in \reals^m)$ 怎么选择方向  通过平移使得原点位于数据中心，则消除了b 第一种通过$J_1$推导即最小化误差方差的方法见教材 找方向使得方差尽可能大    形式化: 最大化方差  方差是衡量新特征包含信息多少的度量 优化目标函数 $J_2(w) = \dfrac{1}{n}\sum_{i=1}^{n} \Vert w^T(x_i-\bar{x})\Vert^2$ 问题: $J_2$可以无穷大或者无穷小(因为可以w全部乘以一个数) 解决办法：加上限制条件$\Vert w\Vert^2 = w^Tw = 1$ $$\mathop{argmax}\limits_w \dfrac{1}{n}\sum_{i=1}^{n} \Vert w^T(x_i-\bar{x})\Vert^2$$ $$s.</description>
    </item>
    
    <item>
      <title>图元生成设备级算法</title>
      <link>https://jarviszly.com/documents/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/%E5%9B%BE%E5%85%83%E7%94%9F%E6%88%90%E8%AE%BE%E5%A4%87%E7%BA%A7%E7%AE%97%E6%B3%95/</link>
      <pubDate>Mon, 16 Mar 2020 16:01:04 +0800</pubDate>
      
      <guid>https://jarviszly.com/documents/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/%E5%9B%BE%E5%85%83%E7%94%9F%E6%88%90%E8%AE%BE%E5%A4%87%E7%BA%A7%E7%AE%97%E6%B3%95/</guid>
      <description>图元生成(设备级)算法 输出图元类型  输出图元：描述图形构成的基本几何结构的子程序。 输出图元的生成：图形的设备级算法。 输出图元两大类  线画图元：矢量表示的二维图形  扫描转换：图形表示的数学方程离散化为点阵表示。   填充图元：点阵表示的二维图形  图形填充：确定图形定义点阵区域的内部点表示。      图元生成的基本操作  图元生成：将图形的几何表示转化为适当的设备操作  画点：将单个坐标位置转换成设备输出操作。 画线：将线路经换为两个指定端点位置间的多个点。    线画图元生成算法 扫描转换  将数学方程(无限的数学点)映射到有限像素区域内的实际的点 扫描转换：按光栅扫描显示原理对数学表示的线段离散取样方法  数值差分分析(DDA)算法  直接利用直线在x或者y方向的增量的线段扫描转换算法 离散取样: 使用x或y方向的单位增量间隔($\Delta x = \pm 1$或者$\Delta y = \pm 1$) 取样方向取决于直线斜率绝对值，哪个轴可变化距离大，就从哪个轴取样。 要求对于每一个像素点位置都必须取整 优点：比直接使用直线方程快 缺点：像素位置计算需要取整。  所以导致累计误差。 取整操作和浮点运算耗时。    </description>
    </item>
    
    <item>
      <title>第三部分</title>
      <link>https://jarviszly.com/documents/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86/</link>
      <pubDate>Wed, 11 Mar 2020 14:06:27 +0800</pubDate>
      
      <guid>https://jarviszly.com/documents/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86/</guid>
      <description>Data Processing Data in the real world  不完全性：主要因为数据收集。 噪声：主要来自数据收集。  数据收集设备不准确 数据传输过程有干扰   不一致：主要来自数据集成  Major tasks of data preprocessing  数据清洗(Data cleaning)  修复丢失数据，消除噪声，解决不一致性等。   数据约简(Data reduction) 数据集成(Data integration)  将不同来源的数据集成   数据转换(Data transformation)  规范化和聚合(aggregation)    Data cleaning filling in missing values  丢弃有缺失的数据(Ignore the tuple) 人工填写缺失值(Fill in the missing value manually) 使用一个全局的常数(Use a global constant)  比如$&amp;quot;unknown&amp;quot;$   使用该属性的均值(Use the attribute mean) 使用同一类中该属性的均值(Use the attribute mean of the same class) 使用可能性最大的数值(Use the most probable value)  smoothing out noisy data  noise：在数据测量过程中随机错误或者误差。 装箱(Binning):  通过数据之间相邻关系来平滑一组排序好的数据   集群(Clustering)  将相似的数据放在同一集群中。   回归(Regression)  使用数学函数   数据审计(Data editing)  使用局部的平滑(local &amp;ldquo;smoothness&amp;rdquo;) 使用全局的一致(global consistency)    correcting inconsistent data  可以使用外部引用来修正一部分不一致数据 一些工具也可用于检测已知数据约束的违反情况  Data integration  模式集成(Schema integration)  元数据可以用来帮助模式集成   冗余处理(Handling redundancy)  在集成多个数据库时可能会出现冗余 一些冗余可以通过相关性分析来检测      Data transformation  规范化(Normalization)  使得属性的取值在一个规定的小范围内   平滑(Smoothing) 聚合(Aggregation) 泛化(Generalizaiton) 属性构造(Attribute construction)  Normalization  min-max normalization  $$v^\prime = \textcolor{green}{\dfrac{v - min_A}{max_A - min_A}}\textcolor{blue}{(new\_max_A - new\_min_A) }+ \textcolor{brown}{new\_min_A}$$  $\textcolor{green}{Part 1}$: 将原数据调整为单位1。 $\textcolor{blue}{Part 2}$: 得到新数据规范化后的长度。 $\textcolor{brown}{Part 3}$: 将新数据移到原来的位置。     z-score normalization  $$v^\prime = \dfrac{v - \bar{v}}{\sigma_v}$$   decimal scalint normalization  $$v^\prime = \dfrac{v}{10^j}$$ j is the smallest int such that $max(\vert v^\prime \vert) &amp;lt; 1$    Data reduction Feature selection/Atrribute Subset selection  去除不相关的属性，从Feature或者说Attribute中挑选一个子集，使得使用该子集的结果概率分布尽可能和原数据靠近。 贪心策略(1)：每次不断挑选最好的 贪心策略(2)：每次移除最差的 贪心策略(3)：每次不断挑选最好的并移除最差的 贪心策略(4)：使用决策树 遗传算法  信息增益(Information gain)  信息熵(information entropy)  信息熵是度量样本集合纯度最常用的一种指。 当前样本集合D中第k类样本所占的比例为$p_k(1,2,\cdots,n)$,则信息熵为 $$Ent(D) = -\sum_{i=1}^n p_k \log_2 p_k$$ $Ent(D)$的值越小，D的纯度越高。   信息增益  假定离散属性a有V个可能的取值$a_1,\cdots,a_v$，如果使用a来对样本集合D进行划分，则产生V个分支节点，其中第v个包含了D中所有在属性a上取值为$a_v$的数据记为$D_v$,则可以针对$D_v$计算出信息熵，同时赋予其权重$\dfrac{\vert D_v \vert}{\vert D\vert}$ 用属性a对样本集D进行划分所得到的信息增益为 $$Gain(D,a) = Ent(D) - \sum_{i=1}^V \dfrac{\vert D_v \vert}{\vert D\vert} Ent(D_v)$$ 一般而言，信息增益越大，则意味着使用属性a进行划分所得到的纯度提升越大。所以我们可以选择属性 $$a^* = \mathop{argmax}\limits_{a} Gain(D,a)$$    </description>
    </item>
    
    <item>
      <title>图形设备输出原理</title>
      <link>https://jarviszly.com/documents/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/%E5%9B%BE%E5%BD%A2%E8%AE%BE%E5%A4%87%E8%BE%93%E5%87%BA%E5%8E%9F%E7%90%86/</link>
      <pubDate>Mon, 09 Mar 2020 13:37:22 +0800</pubDate>
      
      <guid>https://jarviszly.com/documents/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/%E5%9B%BE%E5%BD%A2%E8%AE%BE%E5%A4%87%E8%BE%93%E5%87%BA%E5%8E%9F%E7%90%86/</guid>
      <description>图形输出颜色模型 颜色模型问题  颜色模型：在特定上下文中对颜色的特性和行为的解释方法  没有一种颜色模型能够解释所有的颜色问题 一种颜色模型只能表征一定的颜色范围 要使用不同模型来帮助说明能看到不同的颜色特征。    颜色模型的光颜色提醒  光源用白色来描述  互补色：混合成白色光的两种彩色光源   适当选择两种或多种初始颜色可形成其他颜色  基色：用来生成其他颜色的两种或三种颜色。 颜色范围：使用基色获得一定范围    颜色匹配公里  基色/原色：任意互不相关的三种颜色构成颜色空间的一组基色  任意两种组合不产生另一种颜色 三基色通过适当的混合可以产生一定范围内所有的颜色。   常用三基色RGB  任意一种颜色F表达式$F = R[R] + G[G] + B[B]$(加权和) 亮度是其分亮度之和$Y_F = RY_R + GY_G + BY_B$    颜色特性描述  色彩/色度：基本色彩 纯度/彩度或者饱和度：颜色表现多纯  加入白色可以降低饱和度   明度/亮度：单位时间，角度及投射面上光源辐射的能量 三者关系：  明度：沿着颜色空间的中心线变化 色度：沿着圆周方向变化 纯度：沿着半径变化      CIE标准XYZ颜色模型  各种颜色的加色空间：XYZ是三基色，是虚颜色。 任意一个颜色可以表示为XYZ的加权和。 CIE-XYZ的特别选取：  颜色XYZ空间归一化平面来度量色度：  $X+Y+Z= 1$   颜色坐标分量Y设为其亮度值    标准函数   规范化基色权向量(X,Y,Z)可以得到</description>
    </item>
    
    <item>
      <title>模式识别系统框架</title>
      <link>https://jarviszly.com/documents/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB%E7%B3%BB%E7%BB%9F%E6%A1%86%E6%9E%B6/</link>
      <pubDate>Thu, 05 Mar 2020 09:04:58 +0800</pubDate>
      
      <guid>https://jarviszly.com/documents/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB%E7%B3%BB%E7%BB%9F%E6%A1%86%E6%9E%B6/</guid>
      <description>&lt;h1 id=&#34;最近邻和模式识别系统框架及其个模块简介&#34;&gt;最近邻和模式识别系统框架及其个模块简介&lt;/h1&gt;</description>
    </item>
    
    <item>
      <title>计算机网络-第六章</title>
      <link>https://jarviszly.com/documents/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E5%85%AD%E7%AB%A0/</link>
      <pubDate>Sat, 29 Feb 2020 13:04:41 +0800</pubDate>
      
      <guid>https://jarviszly.com/documents/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E5%85%AD%E7%AB%A0/</guid>
      <description>第六章 链路层概述  运行链路层协议的任何设备称为节点，沿着通信路径连接相邻节点的通信信道称为链路 在通过特定链路时，传输节点将数据报封装在链路层帧中，并将该帧发送到链路中。  链路层服务  成帧(framing)  链路层帧由一个数据字段和若干首部字段组成，其中网络层数据报就插在数据字段中。   链路接入(link access)  协调对共享多访问媒体的访问 媒体访问控制(MAC)协议规定了帧在链路上传输的规则。   可同时发送和接收 可靠交付  保证无差错地经链路层移动每个网络层数据报。   流控制 差错检测和纠正  链路层实现  链路层主体部分是网络适配器(网卡)，位于网卡核心的是链路层控制器，通常是一个实现了许多链路层服务的专用芯片。链路层涉及到硬件，软件和固件。 链路层帧的发送和接收  发送端：将网络层数据报封装成链路层帧，在帧的首部设置差错检测比特。 接收端：检查错误，从链路层帧中抽取网络层数据报传给上层网络层。    差错检测和纠正技术  比特级差错检测和纠正：即对从一个节点发送到另一个物理上连接的邻近节点的链路层帧中的比特损伤进行检测和纠正。 使用 差错检测和纠正比特(EDC) 来增强数据D。 通常要保护的信息除了数据报内容还包括帧首部链路级的寻址信息等。  三种检错纠错技术  奇偶校验  单个奇偶校验位  简单易用 出现偶数个bit错误时无法检测出来，且只可以检测错误。   二维奇偶检验  二位奇偶校验  发生单个错时，可以根据行和列的索引定位纠正错误。 可以检测(但不能纠正)一个分组(同一行或同一列)中任意两个比特错误的组合。 接收方检测和纠正错误的能力交错前向纠错     因特网校验和(Internet checksum)  将数据的自己作为16bit的整数并求和，这个和的 反码 形成了携带在报文段首部的 校验和。(这一步即是二进制反码求和) 二进制反码求和：从低位到高位逐列进行和计算,如果最高位(16位)进位,则得到的结果加1,一直循环到最高位没有进位为止.</description>
    </item>
    
    <item>
      <title>计算机网络-第七章</title>
      <link>https://jarviszly.com/documents/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%83%E7%AB%A0/</link>
      <pubDate>Sat, 29 Feb 2020 13:03:58 +0800</pubDate>
      
      <guid>https://jarviszly.com/documents/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%83%E7%AB%A0/</guid>
      <description>无线网络和移动网络 基本概念   基站：负责协调与之关联的多个无线主机之间数据的传输。比如蜂窝塔，802.11无线LAN中的接入点。
  基础设施模式：与基站关联的主机以此模式运行。
  网络基础设施：无线主机希望与之进行通信的更大的网络。
  单跳和多跳：
 单跳网络：在传统的无线局域网(WLAN)中，每个客户端均通过一条与AP相连的无线链路来访问网络，用户如果要进行相互通信的话，必须首先访问一个固定的接入点(AP)，这种网络结构被称为单跳网络。 多跳网络：在无线多跳网络中，源结点到目的结点之间的典型路径是由多跳组成的，该路径上的中间结点充当转发结点。 单跳和多跳     信噪比(SNR)：所收到的信号和噪声强度的相对测量，信噪比越高，接收方越容易从背景噪声中提取信号。
  比特差错率(BER)：接收方收到有错传输比特的概率。
  无线网络和有线网络的区别  无线网络中信号强度逐渐递减。 无线网络中信号会受到其他源的影响。 无线网络中由于电磁波被反射等影响会出现多径传播。  Ad-Hoc Network  Ad-hoc网络是由相互直接通信的各个设备组成的网络,常常绕过集中的接入点。是点到点的网络，没有基站。  IEEE 802.11 wireless LAN(WiFi)  工作的主要频段：2.4GHz 和 5GHz 体系结构(Architecture):  BSS(基本服务集)：包含一个或多个无线站点和一个接入点(AP)的中央基站，每一个站点和基站都有理论上唯一的6字节的MAC地址存储在该站的适配器(网卡)中。 ESS(拓展服务集)：由DS(分布式系统)连接多个BSS构成，这个DS可以是交换机，有线网络或无线网络，其作为一个逻辑局域网出现。    IEEE 802.11 services  Distribution service and Intergration service  Distribution service: 在ESS中如果一个帧要从一个站点到达另一个BSS中另一个站点，则需要使用该服务，如果两个站点在同一个BSS中，则该服务逻辑上使用单个AP. Intergration service: 当一个站点要发送一个帧到达LAN中时，就使用Intergration service。 DS and IS  IEEE 802.</description>
    </item>
    
    <item>
      <title>计算机网络-第三章</title>
      <link>https://jarviszly.com/documents/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%89%E7%AB%A0/</link>
      <pubDate>Sat, 29 Feb 2020 13:03:02 +0800</pubDate>
      
      <guid>https://jarviszly.com/documents/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%89%E7%AB%A0/</guid>
      <description>第三章 运输层 概述  运输层协议为运行在不同主机上的应用进程之间提供了逻辑通信，其只工作在端系统上，将应用进程的报文移动到网络边缘(网络层)，或者从网络层获取报文。 两个主要的协议：  UDP(用户数据协议)，不可靠的，无序的，无连接的。 TCP(传输控制协议)，可靠的，有序的，面向连接的。   运输层将主机之间的交付扩展到进程间的交互被称为 运输层的多路复用和多路分解。  多路复用和多路分解  $&amp;lt;IP，Port&amp;gt;$这样被称为套接字。 将运输层报文段中数据交付到正确的 套接字的做工称为 多路分解。 从不同套接字收集数据，加上首部，生成报文段后传递到网络层 ，这个工作称为 多路复用。 多路复用和多路分解的要求：  套接字有唯一标识。 报文段中有特殊字段指示所需交付的套接字，即源端口号和目的端口号。 端口号是16比特数，其中$0\sim 1023$这部分是 周知端口号，用于如HTTP等协议使用，其他可以随意分配。 报文段格式     无连接的多路复用和多路分解(UDP)  UDP套接字由一个 二元组(目的主机IP，目的端口号) 唯一确定，在这里源端口号和源IP作用是作为返回地址。  面向连接的多路复用和多路分解(TCP)  TCP套接字由一个 四元组(源IP,源端口号，目的IP，目的端口号) 唯一确定，只有四个属性全部一致的报文才会被发送到同一个端口上，除非该TCP报文段首部的 连接建立位是置位(即该报文用来建立连接)，则都会发送给主机上用来建立连接的端口上。  UDP(用户数据)协议  仅仅提供了复用/分解服务和差错检验服务。  报文段格式：UDP报文格式  其中Checksum用于差错检验，其计算方法和因特网校验和一样，二进制求和取反。 UDP首部为8字节。   UDP协议的优点：  UDP能够立马发送应用层传下来的数据，不会有过分的延迟传输，对于实时应用是很重要的。 不需要建立连接，不需要维持连接，所以没有连接延迟和维持连接的开销。    可靠数据传输原理  经 完全可靠信道传输 的FSM(有限状态机器)  发送方和接收方都有数据就传输，有数据就接收。   经 具有比特差错信道传输 的FSM  加入 差错检验和接收端反馈(ACK/NAK)，即发送后 停止等待 但没有考虑到接收端发送的ACK/NAK也可能受损，解决方法是在数据分组中加入 序号 字段 或者也可不使用NAK而是发送ACK时候带上ACK的分组序号，由发送方判断是否是刚刚发送的分组的ACK从而决定是否要重发。   经 具有比特差错和丢包信道传输 的FSM  加入 定时器，在时间阈值内没有收到正确的ACK则重发。    流水线可靠数据传输协议  针对rdt3的停止等待导致信道利用率低下的问题，改用不使用停止等待，而是允许发送一定量的分组而不需要得到确认。 流水线里面的差错恢复有 回退N步(滑动窗口) 和 选择重传 回退N步    在rdt3的基础上最多允许不加确认的条件下传输N个分组。 一旦超时，则重发从[base,nextseqnum-1]的全部分组。 同时在本协议内，接收端丢弃所有失序分组，也就是说如果第i个分组出现丢包，则i后面的分组都会被接收端丢弃。   选择重传  发送方和接收方各自维护一个大小为N的窗口。 发送方的事件和动作  1.</description>
    </item>
    
    <item>
      <title>计算机网络-第四章</title>
      <link>https://jarviszly.com/documents/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E5%9B%9B%E7%AB%A0/</link>
      <pubDate>Sat, 29 Feb 2020 13:01:43 +0800</pubDate>
      
      <guid>https://jarviszly.com/documents/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E5%9B%9B%E7%AB%A0/</guid>
      <description>第四章 转发和交换(路由选择) 转发  是网络层：数据平面实现的唯一功能。 是指将一个分组从一个输入链路接口转移到适当的输出链路接口的路由器本地动作，时间尺度很短。  交换(路由选择)  是网络层：控制平面的功能，当分组从发送方流向接收方时，网络层需要决定这些分组采用的路由或路径，计算这些路径的算法称为 路由选择算法 是指确定分组从发送方到接收方所采取的端到端路径的网络范围处理过程，事件尺度相对更长。  转发表  每个网络路由器都有一个转发表，路由器在检测到分组首部的若干字段后，用这些首部值在转发表中索引，从而确定分组转发的输出链路接口。 链路层交换机时根据链路层帧首部的字段(如MAC地址)进行转发，而 路由器是根据网络层数据报中的首部(如IP地址)进行转发  路由器工作原理 路由器体系结构 体系结构  交换  经内存交换：通过终端路由选择处理器 经总线交换：通过给分组打上标签，到达本地输出链路后去除标签。 经互联网络交换：允许并行，交换时将沿途结点封锁。    基于目的地的转发  路由器转发表采用前缀匹配的方式生成表项，对于每一个链路接口，其目的地址范围的前缀为表项中的前缀匹配。 在收到分组时，路由器用分组的目的地址和表项中的前缀匹配，匹配成功则将该分组转发到对应的链路接口。 当存在多个成功匹配时，采用 最长前缀匹配规则，转发到匹配长度最长的那个链路接口。  分组调度  排队的分组如何经输出链路传输。 先进先出(FIFO) 优先权排队  将到达输出链路的分组按照优先级分成多个类，优先级高的类先传输，类内采用FIFO的方式。 非抢占式优先权排队：一旦分组开始被传输，即使此时有更高优先级的分组到达，该分组的传输也不会被打断。   循环排队规则  也将分组分成多个类，循环调度器在类之间轮流传输。   加权公平排队  和循环排队类似，但是在第i个类有需要发送的分组的任何时间间隔中，都能保证该类等待发送的分组中有$w_i/(\sum w_j)$的部分接收到了发送服务。    网际协议：IP IPv4 IPv4数据报格式 IPv4   版本号：规定了数据报IP协议版本，路由器根据该部分决定如何识别解释后面的部分 首部长度：一般为20字节。 服务类型：说明该IP数据报是什么类型。 数据报长度：整个IP数据报总长度。 标识，标志，片偏移：和IP分片相关。 寿命(TTL): 确保数据报不会再网络中循环，没经过一个路由器该值-1，为0时丢弃。 上层协议：指示了IP数据报的数据部分应该交给哪一个特定的运输层协议。 首部校验和：帮助路由器检测IP数据报中的比特错误。 源/目的IP地址，选项，数据。  IPv4数据报分片  分片原因：由于不同的链路层协议的 最大传送单元不一样，有时一个链路层帧并不能完全承载一个IP数据报的内容，故需要将IP数据报分片。 最大传送单元：一个链路层帧能够承载的最大数据量。 IPv4将重组IP数据报的工作交给了端系统。 IPv4数据报分片利用标识，标志，片偏移三个字段：  发送主机通常将它发送的每一个数据报的标识号依次加1.</description>
    </item>
    
    <item>
      <title>计算机网络-第五章</title>
      <link>https://jarviszly.com/documents/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0/</link>
      <pubDate>Sat, 29 Feb 2020 13:00:33 +0800</pubDate>
      
      <guid>https://jarviszly.com/documents/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0/</guid>
      <description>第五章 路由选择算法  路由选择算法的目的是从发送方到接收方的过程中确定一条通过路由器网络的好的路径。  分类  集中式路由选择算法和分散式路由选择算法  集中式路由选择算法：用完整的全局性的网络信息计算出最低开销路径，以所有节点之间的连通性及所有链路的开销作为输入，如链路状态算法(LS) 分散式路由选择算法：路由器以 迭代，分布式方法计算出最低开销路径，每个节点仅有与其直接相连的链路开销信息即可开始工作。如 距离向量算法(DV)   静态路由选择算法和动态路由选择算法 负载敏感算法和负载迟钝算法  现在因特网路由选择算法(RIP,OSPF,BGP)都是负载迟钝算法。    LS算法  在该算法中，网络拓扑和所有链路开销都是已知的。实践中是通过让每个节点向网络中广播链路状态分组来完成的。其中链路状态分组包含和自己相连的链路的开销信息，这常常由 链路状态广播算法完成。 使用协议：OSPF，使用的算法：Dijkstra算法，复杂度$O({|V|}^2)$  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  1 Initialization: 2 N’ = {u} 3 for all nodes v 4 if v is a neighbor of u 5 then D(v) = c(u, v) 6 else D(v) = ∞ 7 8 Loop 9 find w not in N’ such that D(w) is a minimum 10 add w to N’ 11 update D(v) for each neighbor v of w and not in N’: 12 D(v) = min(D(v), D(w)+ c(w, v) ) 13 /* new cost to v is either old cost to v or known 14 least path cost to w plus cost from w to v */ 15 until N’= N    链路状态算法运行过程： table  存在的问题：拥塞敏感的选择振荡  在拥塞敏感且将路径负载当作开销的情况下，所有路由器同时运行LS算法，会使得由于选择了某一条目前最短开销路径而导致网络中路径开销改变，LS算法得出的最短开销路径会不断摇摆振荡。 解决办法是 使每台路由器广播链路状态分组的时间随机化。    DV算法  该算法是一种 迭代的，异步的，分布式的算法，使用的协议有BGP，RIP.</description>
    </item>
    
    <item>
      <title>计算机网络-拥塞和Qos</title>
      <link>https://jarviszly.com/documents/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%8B%A5%E5%A1%9E%E5%92%8Cqos/</link>
      <pubDate>Sat, 29 Feb 2020 12:59:22 +0800</pubDate>
      
      <guid>https://jarviszly.com/documents/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%8B%A5%E5%A1%9E%E5%92%8Cqos/</guid>
      <description>拥塞和Qos 拥塞 拥塞原因  大量分组在网络上传输，数量超出路由器的处理能力。  拥塞代价  造成丢包，时延；重传使得浪费之前发送的资源。  拥塞控制方法   抑制分组(choke packet): 产生拥塞的路由器通过特定协议(如ICMP)向源端系统发送抑制分组来抑制源端系统的分组发送。
  反向施压(Backpressure): 当传播时间大于传输时间时，choke packet往往没有作用，则通过产生拥塞路由器向前面一个路由器反向施压抑制前面路由器的发送，这样传递下去，最终影响到源端系统。
  标志位(Warning bit): 通过在分组上设置一个标志位来告诉端系统可能发生拥塞。
 前向标记(FECN): 发生拥塞相同的方向 后向标记(BECN): 发生拥塞相反的方向    拥塞窗口：使用在端系统上(如TCP)
  早期随机丢弃(RED): 作用在路由器上，该方式设置一个下限 $L_{min}$，一个上限 $L_{max}$。
 当队列的长度小于小于下限时，保证不会丢掉分组 当队列的长度介于上下限之间时，对于每一个接收到的分组，路由器以概率 p丢弃 当队列长度完全大于上限时，丢弃接收到的分组。    流量整形（Traffic shaping): 在建立连接之后，端系统和路由器之间协商流量整形的方式。
 约定数据速率(CIR): RED方式。 漏桶：通过像漏斗一样的东西控制流量，输入速率随意，输出速率固定。 令牌桶：允许多变的输出速率。  令牌桶容量：一次性最多能够输出分组的数量。 令牌产生的速率：用来控制输出分组的平均速率 可以在令牌桶后面连接一个容量为1的令牌桶来控制峰值速率      Qos的两种服务 ISA(Integrated Services Architecture)  由于太复杂，现在还没用。  DS(Differentiated Services)差异化服务  使用IPv4和IPv6里面的服务类型和流量类型来区分不同的分组的重要性。  </description>
    </item>
    
    <item>
      <title>微电子笔记第三章</title>
      <link>https://jarviszly.com/documents/%E5%BE%AE%E7%94%B5%E5%AD%90%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%89%E7%AB%A0/</link>
      <pubDate>Sat, 29 Feb 2020 12:58:03 +0800</pubDate>
      
      <guid>https://jarviszly.com/documents/%E5%BE%AE%E7%94%B5%E5%AD%90%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%89%E7%AB%A0/</guid>
      <description>半导体物理基础 半导体材料  根据物体导电能力分为导体,绝缘体，半导体，其中导体电阻率$\rho&amp;lt;10^{-4} \Omega\cdot cm$,绝缘体电阻率$\rho &amp;gt; 10^9 \Omega\cdot cm$,半导体电阻率介于两者之间。 半导体导电能力和 温度，光照，掺杂浓度相关。 典型半导体有 硅Si,锗Ge,砷化镓GaAs 半导体共价键结构：一般为四价元素，最外层四个电子被称为价电子，和周围四个原子的价电子分别形成共价键。  本征半导体,空穴及导电作用  本征半导体：化学成分纯净的半导体，物理结构呈单晶体形态。纯度到要达到9个9 载流子：可以自由移动的带电粒子。 电导率：与材料单位体积中所含的载流子数量相关，载流子浓度越高，电导率越高。 本征激发：半导体受到光，热激发时，某些电子可以从外界获得挣脱共价键束缚的能量，从而离开原子成为自由电子，同时再共价键中留下相同数量的空穴。 空穴：共价键中的空位。(空穴的出现是半导体区别于导体的一个特点) 电子空穴对：由热激发而产生的自由电子和空穴对。 空穴的移动是依靠相邻共价键中的价电子依次填充空穴来实现的。 复合：当自由电子遇到空穴后相互结合形成一个新的共价键。 在温度一定时，本征激发和复合会达到动态平衡。 重要特性：  本征半导体中自由电子和空穴总是成对产生，数量随温度增高而显著增加。 空穴的导电作用   本征半导体的缺点：载流子少，导电性差，温度稳定性差。  杂质半导体  定义：在本征半导体中掺入某些微量元素作为杂质，可以使半导体的导电性发生显著变化，主要掺入的是三价元素或五价元素。 P型半导体：掺入三价杂质元素(如硼，镓，铟)等。  因三价原子和硅原子形成共价键时，缺少一个价电子从而留下一个空穴 在P型半导体中，空穴(p)是多数载流子(多子)，主要由掺杂形成，自由电子(n)是少数载流子(少子)，由热激发形成，空穴很容易俘获电子，使得杂质原子成为负离子，三价杂质因此也被称为受主杂质($N_A$) 满足公式 $N_A+n = p$   N型半导体：掺入五价杂质元素(如磷)。  因五价原子只有四个价电子可以和硅的价电子形成共价键，所以多余的一个价电子没有束缚而称为自由电子。 在N型半导体中，自由电子(n)是多子，主要由掺杂形成，空穴(p)是少子，由热激发形成，提供自由电子的五价原子成为正离子，被称为施主杂质($N_D$) 满足公式 $N_D+p = n$    载流子的漂移和扩散  漂移电流：在电场作用下，载流子在电场中的漂移运动形成的电流。  $v_n = -\mu_n E$,$v_p = \mu_p E$,其中$\mu$为对应的载流子迁移率。 $I = -\nu\cdot Width\cdot Height\cdot n\cdot q$   扩散电流：因浓度差，载流子从高浓度向低浓度扩散而形成的电流。  PN结  在一块本征半导体两侧扩散不同的杂质原子，使得一边为P型一边为N型，两边多子由于浓度差，向对方扩撒，从而内部的空间电荷区形成一个电场，内电场抑制多子扩散，同时促进少子漂移，最终达到平衡。P，N型半导体接合面，离子薄层形成的 空间电荷区被称为PN结 单向导电性  在PN结外部加上电压，当P区电位高于N区电位，称为加上了正向电压，简称为正偏，反之为反向电压，简称反偏。 正偏时，外部电压促进多子扩散，从而导致中间空间电荷区变窄，PN结呈现的状态是低电阻状态，大的正向扩散电流 反偏时，外部电压一直多子扩散，促进少子漂移，从而导致空间电荷区变宽，PN结呈现的状态是高电压，小的反向漂移电流。在一定温度下，本征激发形成的少子数量一定，此时形成的漂移电流一定，和外部电压无关，称为反向饱和电流。 V-I特性表达式: $i_D = I_s(e^{V_d/V_T}-1)$，其中$I_s$为反向饱和电流，$V_T$为温度的电压当量，常温(300K)下$V_T = \dfrac{kT}{q} = 26mv$   反向击穿  当反向电压达到一定数值时，反向电流突然快速增加的现象。 分为电击穿(雪崩击穿，齐纳击穿)此时可逆，热击穿此时不可逆。 雪崩击穿：空间电荷区的电子在电场中获得足够的动能撞击其他原子从而产生更多的自由电子-空穴对，新的电子又同样撞击其他原子，如此连锁反应，使得载流子数量雪崩式增加，从而导致电流急剧加大。具有正的温度系数 齐纳击穿：反向电压足够大时，在电场的作用下，价电子之间的共价键被拉断，从而价电子变成自由电子，自由电子在电场的作用下移动到N区，空穴移动到P区，使得电流急剧增大。常发生在掺杂浓度较高的PN结中，具有负的温度系数(温度升高，共价键更容易被破坏)。    二极管 PN结上加上引线和封装就是一个二极管。</description>
    </item>
    
    <item>
      <title>微电子笔记</title>
      <link>https://jarviszly.com/documents/%E5%BE%AE%E7%94%B5%E5%AD%90%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Sat, 29 Feb 2020 12:57:01 +0800</pubDate>
      
      <guid>https://jarviszly.com/documents/%E5%BE%AE%E7%94%B5%E5%AD%90%E7%AC%94%E8%AE%B0/</guid>
      <description>第一章 电子计算机  电子管时代：  1940s-1950s ENIAC(1946,ABC公司)，电子数字积分计算器。   晶体管时代：  1950s-1960s 晶体管：一种用以代替真空管的电子信号放大元件。 1947年贝尔实验室制造成功了第一个半导体晶体管 1949年贝尔实验室做出了第一个锗PNP型晶体管。 1956年bardeen,Shockley,Brattain获得诺贝尔物理学奖。 TRADIC(1954):世界上第一台全晶体管计算机。   集成电路时代：  1960s- 1958年，Jack Kilby发明了第一块锗集成电路振荡器。（2000诺贝尔物理学奖） 1970年，Intel推出第一个商用 动态随机存储器(DRAM)1103,容量1 Kbits,标志这大规模集成电路(LSI)出现。 1978年，64kbDRAM出现标志这进入了超大规模集成电路时代。    摩尔定律  定义：IC集成度每一年提高一倍，即技术每两年提升一代，1975年修正：进入80年代后，技术每3年提升一代。 技术基础：不断缩小的晶体管尺寸。  集成电路规模  SSI: $&amp;lt;10^2$ MSI: $10^2$~$10^3$ LSI: $10^3$~$10^5$ VLSI: $10^5$~$10^7$ ULSI: $10^7$~$10^9$ GLSI: $&amp;gt;10^9$  微电子学定义 研究在固体（主要是半导体材料）上构成的微小化电路及系统的电子学分支，主要是研究电子或离子在固体材料中的运动规律及其应用，并利用它实现电磁信号和信息处理功能的电子科学。它以实现电路和系统的集成为目的。微电子学中实现的电路和系统又称为集成电路和集成系统，是微小化的；在微电子学中的空间尺寸通常是以微米（μm，1μm=10 − 6m）和纳米（nm，1nm=10 − 9 m）为单位的。
微电子学应用领域  逻辑电路 储存电路 通信电路 平板显示 &amp;hellip;&amp;hellip;  微电子技术 微电子技术是随着集成电路尤其是超大规模集成电路发展起来的技术。主要包括了电路系统设计，器件物理，工艺技术，材料制备，测试和封装的专门的技术，是微电子学中各项工艺技术的总和。
集成电路  定义：是通过一系列加工工艺，将晶体管按照一定的电路互连在一块半导体单晶片上并封装在外壳中来执行特定的电路或系统功能的电路。 制造过程：电路设计，工艺制造，测试封装。 核心：单元器件 晶体管是组成集成电路最基本的单位。 分类：  器件构造模型：  双极集成电路：由双极晶体管构成，如PNP型、NPN型，优点是速度快，驱动力强，缺点是集成度不高，功耗大 金属-氧化物-半导体(MOS)集成电路：如NMOS,PMOS,CMOS，优点是集成高，功耗小，随着特征尺寸缩小，速度也快。 双极-MOS集成电路：综合上面，有上面的优点，但制作工艺复杂。   集成规模：见上 制作工艺：  单片集成电路：电路中所有的元器件都集成在同一块半导体基片上的集成电路。 混合集成电路： 薄膜集成电路，厚膜集成电路   应用领域：  数字集成电路：处理数字信号的集成电路，即采用二进制方式进行数字计算和逻辑函数运算的集成电路 模拟集成电路：处理模拟信号的集成电路(连续变化的信号)，分线性集成(运算放大器)和非线性集成(振荡器) 数模混合集成电路：如数模转化器。      微电子学器件  定义：可以构成集成电路的最小单元。 最具代表性器件：场效应晶体管。  微电子学核心研究内容之一就是怎么实现更小尺寸的晶体管</description>
    </item>
    
    <item>
      <title>组合数学</title>
      <link>https://jarviszly.com/documents/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/</link>
      <pubDate>Sat, 29 Feb 2020 12:55:20 +0800</pubDate>
      
      <guid>https://jarviszly.com/documents/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/</guid>
      <description>&lt;h1 id=&#34;基本计数&#34;&gt;基本计数&lt;/h1&gt;</description>
    </item>
    
    <item>
      <title>数据库</title>
      <link>https://jarviszly.com/documents/%E6%95%B0%E6%8D%AE%E5%BA%93/</link>
      <pubDate>Sat, 29 Feb 2020 12:53:01 +0800</pubDate>
      
      <guid>https://jarviszly.com/documents/%E6%95%B0%E6%8D%AE%E5%BA%93/</guid>
      <description>数据库 Tips  注意只有$\cdots$的的时候，在关系代数中是考虑被减数取哪一个关系，而在关系演算中是考虑是否要多加一项来保证类似于选过课，买过商品的约束，在sql中考虑是否通过类似于where sno in (select sno from SC where&amp;hellip;)来保证  关于加入成绩的关系代数  选修了CS系开设的所有课程且所修的所有课程成绩合格 $$(\pi_{sno,cno}(L) \div \pi_{cno}(\sigma_{dept = &amp;lsquo;CS&amp;rsquo;}(C))) - \pi_{sno}(\sigma_{g &amp;lt; 60}(L))$$ 选修了CS系开设的所有课程且这些课程的成绩合格 $$\pi_{sno,cno}(\sigma_{g \geq 60}(L))\div \pi_{cno}(\sigma_{dept = &amp;lsquo;CS&amp;rsquo;}(C))$$ 选修了自己院系开设的所有课程且这些课程成绩合格 $$\pi_{sno}(L) - \pi_{sno}[\pi_{sno,cno}(C \infty S) - \pi_{sno,cno}(\sigma_{g \geq 60}(L))]$$ 像这种对自己院系(城市)的所有什么做了什么的情况通常用减法来表示除法  两重所有  通过所有销售过所有的商品的供应商购买过商品的客户
销售过所有商品的供应商：$\pi_{aid,pid}(O) \div \pi_{pid}(P)$ $$\pi_{cid,aid}(O) \div (\pi_{aid,pid}(O) \div \pi_{pid}(P))$$ 向NY市所有客户都销售过所有单价大于1的商品的供应商
此处并非使用两个除法，需要搞清楚条件是什么!!,除数应该是NY市的客户和单价大于1的商品两个集合的笛卡尔乘积：$\pi_{cid}(\sigma_{city =&#39;NY&amp;rsquo;}(C)) \times \pi_{pid}(\sigma_{price &amp;gt; 1}(P))$ $$\pi_{aid,cid,pid}(O)\div [\pi_{cid}(\sigma_{city =&#39;NY&amp;rsquo;}(C)) \times \pi_{pid}(\sigma_{price &amp;gt; 1}(P))]$$  </description>
    </item>
    
    <item>
      <title>语法分析</title>
      <link>https://jarviszly.com/documents/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/</link>
      <pubDate>Thu, 27 Feb 2020 10:06:04 +0800</pubDate>
      
      <guid>https://jarviszly.com/documents/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/</guid>
      <description>语法分析 语法分析器  基本作用  从词法分析器获得词法单元序列，确认该序列是否可以由语言的文法生成 对于语法错误的程序，报告错误信息 对于语法正确的程序，生成语法分析树(语法树) 语法分析器    分类  自顶向下语法分析器(用于处理LL文法)  从语法分析树的根部开始构造语法分析树   自底向上语法分析器(用于处理LR文法)  从语法分析树的叶子开始构造语法分析树   两个第一个L都表示从左到右，逐个扫描词法单元    上下文无关文法(CFG) 组成部分  终结符号：组成串的基本符号(词法单元名字) 非终结符号：表示串的集合的语法变量  在程序设计语言中通常对应于某个程序构造如$\textit{stmt}$   开始符号：某个被指定的非终结符号  对应的串的集合就是文法的语言   产生式：描述将终结符号和非终结符号组成串的方法  形式：头(左)部$\rightarrow$ 体(右)部 头部是一个非终结符号，右边是一个符号串 例如:$\textit{expression} \rightarrow \textit{expression} + \textit{term}$(加法表达式)    例子  简单算术表达式文法  终结符号: $id,+,-,*,/,(,)$ 非终结符号：$\textit{expression}, \textit{term}, \textit{factor}$ 开始符号：$\textit{expression}$ 产生式集合  $\textit{expression} \rightarrow \textit{expression} + \textit{term}$ $\textit{expression} \rightarrow \textit{expression} - \textit{term}$ $\textit{expression} \rightarrow \textit{term}$ $\textit{term} \rightarrow \textit{term} * \textit{factor}$ $\textit{term} \rightarrow \textit{term} / \textit{factor}$ $\textit{term} \rightarrow \textit{factor}$ $\textit{factor} \rightarrow (\textit{expression})$ $\textit{factor} \rightarrow id$   简单表示方法  $E\rightarrow E + T | E - T | T$ $T\rightarrow T*F | T / F | F$ $F\rightarrow (E) | id$ 上面的$|$是元符号      推导  将待处理的串的某个非终结符号替换为这个非终结符号的某个产生式的体(用右边替换左边) 从开始符号出发，不断替换，最终可以得到不同的 句型 正式定义   如果$A\rightarrow \gamma$是一个产生式，那么$\alpha A \beta \Longrightarrow \alpha \gamma \beta$</description>
    </item>
    
    <item>
      <title>第二部分</title>
      <link>https://jarviszly.com/documents/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86/</link>
      <pubDate>Wed, 26 Feb 2020 19:36:58 +0800</pubDate>
      
      <guid>https://jarviszly.com/documents/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86/</guid>
      <description>&lt;h1 id=&#34;data-cube-and-olap&#34;&gt;Data Cube And OLAP&lt;/h1&gt;</description>
    </item>
    
    <item>
      <title>数学基础</title>
      <link>https://jarviszly.com/documents/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Sun, 23 Feb 2020 15:36:25 +0800</pubDate>
      
      <guid>https://jarviszly.com/documents/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/</guid>
      <description>&lt;h1 id=&#34;模式识别数学基础&#34;&gt;模式识别数学基础&lt;/h1&gt;</description>
    </item>
    
    <item>
      <title>计算机图形学概论</title>
      <link>https://jarviszly.com/documents/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E6%A6%82%E8%AE%BA/</link>
      <pubDate>Mon, 17 Feb 2020 14:38:35 +0800</pubDate>
      
      <guid>https://jarviszly.com/documents/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E6%A6%82%E8%AE%BA/</guid>
      <description>&lt;h1 id=&#34;概论&#34;&gt;概论&lt;/h1&gt;</description>
    </item>
    
  </channel>
</rss>
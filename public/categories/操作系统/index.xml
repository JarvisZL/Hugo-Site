<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>操作系统 on 浙语临湖</title>
    <link>https://jarviszly.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</link>
    <description>Recent content in 操作系统 on 浙语临湖</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
    <lastBuildDate>Mon, 15 Jun 2020 12:30:41 +0800</lastBuildDate>
    
	<atom:link href="https://jarviszly.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>进程抽象</title>
      <link>https://jarviszly.com/documents/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E6%8A%BD%E8%B1%A1/</link>
      <pubDate>Mon, 15 Jun 2020 12:30:41 +0800</pubDate>
      
      <guid>https://jarviszly.com/documents/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E6%8A%BD%E8%B1%A1/</guid>
      <description>回顾操作系统   在应用程序看来操作系统就是一组系统调用。
  在底层硬件看来操作系统就是一个C程序，一个状态机。
  操作系统是对进程状态机的模拟，这种模拟就是所谓的虚拟化，进程认为自己独占cpu。
  操作系统中常见API
 进程(状态机)管理  fork: 拷贝一份当前的进程(包括内存，寄存器现场，操作系统的对象，libc中缓冲区等等)。 execve: 替换当前进程为另一个进程，从头执行。 exit: 退出当前进程。   存储(地址空间)管理  mmap: 地址空间和物理内存之间的映射。 brk: 虚拟地址空间管理   文件(数据对象)管理  open,close: 文件访问管理 read,write: 数据管理 mkdir, link, unlink: 目录管理      进程抽象-fork,execve,exit fork  复制一个一摸一样的进程出来，一个返回子进程pid，子进程则返回0。  1 2 3 4 5 6  #define N 2 for(int i = 0; i &amp;lt; N; ++i){ fork(); printf(&amp;#34;hello,world.</description>
    </item>
    
    <item>
      <title>虚存,Linux进程地址空间</title>
      <link>https://jarviszly.com/documents/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%99%9A%E5%AD%98linux%E8%BF%9B%E7%A8%8B%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/</link>
      <pubDate>Thu, 11 Jun 2020 22:51:05 +0800</pubDate>
      
      <guid>https://jarviszly.com/documents/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%99%9A%E5%AD%98linux%E8%BF%9B%E7%A8%8B%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/</guid>
      <description>Linux进程的地址空间  进程的地址空间如何创建，创建之后如何修改？  1 2 3 4 5 6 7  //映射 void* mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset); int munmap(void *addr, size_t length); //修改映射权限 int mprotect(void *addr, size_t length, int prot);     看mmap手册可以知道其作用是可以将某个文件中的一部分映射到内存中一部分，所以很容易可以想到在进程地址空间创建时，需要将进程的代码和数据搬到地址空间，所以可以用mmap来当作加载器。
  那么mmap又是如何实现的，通过strace观察mmap可以发现，其使用了/proc/proc_id/maps文件中的信息，这个文件中记录了该进程的所有内容在文件和地址空间间的映射关系。
  通过cat查看/proc/proc_id/maps的内容，可以发现进程的地址空间为
     动态链接库在heap和stack之间
  而在地址空间最后三个部分，发现了三个神秘的东西(vvar,vdso,vsyscall)
 vvar: 内核和进程共享的数据 vdso: 系统调用的代码实现，这些系统调用不需要陷入内核执行。(比如time，getcpu等) vsyscall: 以前的系统调用的代码实现，但因为安全问题，已经不再使用，为了向后兼容而保留。    虚拟存储-分页机制  为了实现mmap这样的映射机制，硬件给予的支持就是虚拟存储-分页机制。 而分页机制最本质的问题就是找一个合适的数据结构来表示虚拟地址到物理地址的映射关系，已经将虚拟地址和物理地址以页为单位划分，则需要表示$2^{20}$到$2^{20}$的映射关系。 使用数组是第一个很直观的想法，但是数组开销太大，无法忍受。 使用radix-tree(基数树)  在32位机器中，设定一页为4KB，一个指针为4B，所以一页可以存放1024个指针，所以一页可以表示10位，每一个指针又指向这样一个页面，于是两级表示了20位，在第二级结点中，每个指针直接指向一个实际的页面，于是总共表示了32位。 在64位机器中，用了4级表示了48位，实际上64位机器其物理地址为48位。    </description>
    </item>
    
    <item>
      <title>同步{条件变量，信号量，生产者消费者问题，哲学家吃饭问题}</title>
      <link>https://jarviszly.com/documents/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%90%8C%E6%AD%A5%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%90%83%E9%A5%AD%E9%97%AE%E9%A2%98/</link>
      <pubDate>Tue, 09 Jun 2020 22:29:06 +0800</pubDate>
      
      <guid>https://jarviszly.com/documents/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%90%8C%E6%AD%A5%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%90%83%E9%A5%AD%E9%97%AE%E9%A2%98/</guid>
      <description>同步  两个(或多个)线程在一定时间内保持一定的关联。 直白的来说：  互斥：各个线程单独完成自己的事情。 同步：多个线程协作完成一件事情，所以在某些时候线程之间需要知道彼此的状态。    实现同步 条件变量(极其重要)  同步的本质: 当一个条件满足时，线程继续执行，否则等待。 则用一个条件变量(对象)对应表示该条件。  当条件不满足时，在该对象处等待。 当一个线程发现某个条件满足时，唤醒该条件变量对应的线程(一个或者所有)   条件变量API  1 2 3  wait(&amp;amp;cv); //在cv条件变量处等在。 signal(&amp;amp;cv)/notify(&amp;amp;cv); //唤醒一个cv条件变量对应线程。 broadcast(&amp;amp;cv)/notifyall(&amp;amp;cv); //唤醒cv条件变量对应的所有线程。    在使用条件变量时，常常需要使用某个变量来表示条件，而该变量是所有线程共享的，所以在访问时需要使用锁(互斥锁)来保护，所以条件变量搭配互斥锁一起完成同步  1 2 3 4 5 6 7  mutex_lock(&amp;amp;mutex); // do some things wait(&amp;amp;cv,&amp;amp;mutex); //在wait中会先释放掉该互斥锁，再等待，被唤醒时会先尝试重新获得该互斥锁。 // do some things mutex_unlock(&amp;amp;mutex); //signal不需要用mutexlock保护    需要注意的是使用条件变量是一定一个条件对应一个条件变量。  信号量  信号量 = 带计数条件变量(相当于条件变量和控制条件的变量综合) + 互斥锁。 通俗理解：将信号量看作更衣室的手环，拿到手环才可以进入更衣室否则等待。 当手环数量为1时，信号量的作用和互斥锁一致。 信号量API  1 2  P(&amp;amp;semv); //申请一个手环，如果拿到就返回否则等待。 V(&amp;amp;semv); //用户生成一个手环，交给等待用户或者管理者。   经典同步问题 生产者消费者问题   问题描述：</description>
    </item>
    
    <item>
      <title>并发数据结构malloc Free算法</title>
      <link>https://jarviszly.com/documents/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B9%B6%E5%8F%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84malloc-free%E7%AE%97%E6%B3%95/</link>
      <pubDate>Sat, 30 May 2020 21:37:09 +0800</pubDate>
      
      <guid>https://jarviszly.com/documents/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B9%B6%E5%8F%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84malloc-free%E7%AE%97%E6%B3%95/</guid>
      <description>并发数据结构-并发链表  在要使用很多次链表的场合，定义链表头时应该直接定义为一个链表结点，而不是一个指针。  当链表头是一个指针时，在操作时就需要考虑指针是否为空的情况。 当链表头是一个结点时，就不需要考虑这个情况，此时链表头不存储任何数据 。    </description>
    </item>
    
    <item>
      <title>操作系统中的互斥</title>
      <link>https://jarviszly.com/documents/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E4%BA%92%E6%96%A5/</link>
      <pubDate>Sat, 30 May 2020 20:56:25 +0800</pubDate>
      
      <guid>https://jarviszly.com/documents/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E4%BA%92%E6%96%A5/</guid>
      <description>操作系统上的互斥(多处理器多线程) 1 2 3 4 5 6 7  void func(void* arg){ while(1){ lock(&amp;amp;biglock); printf(&amp;#34;Thread-%s on CPU #%d acuquired the lock\n&amp;#34;,arg,_cpu()); unlock(&amp;amp;biglock); } }    上述代码在多处理器上多线程运行时会发现一段时间后，总是一个线程在一个处理器上获得锁。safety和liveness都没问题而,fairness出现了问题。 使用状态机来理解发现：对于持有了锁的线程，其中断大概率出现在printf，而此时其他CPU上的其他线程都处于自旋状态，结果绕一圈回到自己继续执行。 这说明：获得自选锁的线程(处理器)不应该被中断，否则会因为其他线程的自旋浪费时间，所以可以在lock函数中加入关中断，在unlock中加入开中断  1 2 3 4 5 6 7 8 9  void spin_lock(spinlock_t &amp;amp;lk){ cli(); while(atomic_xchg(&amp;amp;lk-&amp;gt;locked,1)); } void spin_unlock(spinlock_t &amp;amp;lk){ atomic_xchg(&amp;amp;lk-&amp;gt;locked,0); sti(); }    而上述代码又面临一个问题，如果一个线程多次获得不同的锁，之后又依次释放锁，则结果第一次释放锁就导致开中断，因此需要保存第一次获得锁的时候线程(CPU)中断状态，在最后一次释放锁的时候还原状态。 所以需要在CPU的结构中加上记录当前CPU关中断计数以及首次关中断时 %eflags &amp;amp; FL_IF的值  互斥锁  自旋锁由于可能导致浪费很多资源，所以其只适用于很短并且希望能立即执行的临界区。而有的时候，只有互斥的需求但不介意被打断或者自身等待。 比如在读写磁盘时，此时如果使用自旋锁，会导致浪费很多时间，并且在这段时间内可能有很多中断，但由于关中断的原因无法到达CPU. 互斥锁的需求分析  持有锁的线程  允许处理器相应中断。 允许切换到其他线程。   等待锁的线程  不要占用处理器资源自旋。     一个很简单的想法就是当我发现自身无法得到锁，需要自旋时就让另一个线程执行。  1 2 3 4 5  void mutex_lock(mutexlock_t &amp;amp;lk){ while(atomic_xchg(&amp;amp;lk-&amp;gt;locked, 1)){ let_another_thread_to_execute(); } }    上述方法值得优化的点在于：可能等待锁的线程有很多，前面需要空转很多线程(每个线程都会atomic_xchg)才能让真正可以执行的线程执行。 所以可以加上一个调度者，每当线程无法获得锁时就直接放弃对CPU的占有，陷入等待，等待调度者的调度。 添加一个等待队列这样的并发数据结构，由调度者控制  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  void mutex_lock(mutexlock_t &amp;amp;lk){ int acquired = 0; spin_lock(&amp;amp;lk-&amp;gt;spinlock);//保护等待队列  if(lk-&amp;gt;locked !</description>
    </item>
    
    <item>
      <title>硬件初始化与操作系统加载</title>
      <link>https://jarviszly.com/documents/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%A1%AC%E4%BB%B6%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8A%A0%E8%BD%BD/</link>
      <pubDate>Wed, 20 May 2020 21:52:55 +0800</pubDate>
      
      <guid>https://jarviszly.com/documents/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%A1%AC%E4%BB%B6%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8A%A0%E8%BD%BD/</guid>
      <description>硬件初始化   硬件和软件之前存在一定的约束
 CPU reset后其处于一个确定的状态，其PC指针一般指向一段ROM,而这个ROM中存储了硬件厂商提供了firmware(固件) 此时处理器大部分特性都是关闭的比如缓存，虚存    Firmware(BIOS, UEFI)
 将用户数据加载到内存  存储介质上的二级loader(比如x86) 直接加载操作系统(嵌入式系统)      Legacy BIOS的约定
 会把引导盘的第一个扇区(512B)加载到内存，然后跳转到这部分执行    操作系统的加载   BIOS加载的512字节中包含了
 16bit $\rightarrow$ 32bit ELF32/64的通用loader    执行完16位向32位的转换后，会跳转到通用loader上执行，该通用loader默认引导盘的存储形式为    所以该loader会先将main函数的参数加载到内存，然后接着加载剩余ELF文件的第一页(4KB),然后根据第一页中ELF文件头的信息，加载剩余所需要的部分，完成ELF文件加载，就跳转到该ELF文件的入口处执行
  ELF文件开始就是从32位模式，转为64位模式，然后建立页表，设置段寄存器，完成初始化，跳转执行。
  跳转执行后，会完成很多cpu的初始化，然后切换堆栈，跳转去执行main.
  </description>
    </item>
    
    <item>
      <title>线程的互斥</title>
      <link>https://jarviszly.com/documents/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BA%92%E6%96%A5/</link>
      <pubDate>Sat, 16 May 2020 23:23:18 +0800</pubDate>
      
      <guid>https://jarviszly.com/documents/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BA%92%E6%96%A5/</guid>
      <description>在现代处理器上Peterson算法的问题  Peterson算法中的，x = 1; turn = T2; 在处理器上会变成指令store(x, 1) store(turn, T2).而因为store指令都比较耗费时间，所以在现代处理器的优化下，处理器会指令后面的指令从而导致两个线程都进入临界区。 很大的问题在于在计算机世界中，我们无法同时&amp;quot;看&amp;quot;和&amp;quot;做&amp;quot;即不能同时load 和 store.  共享内存带来更多的问题  由于不能同时load和store所以当线程共享内存时，会引发其他问题，比如多线程求sum. 四个线程求和放入同一个变量，加法对应的指令只有一条add，如果按照状态机的假设，每次只执行一条指令且指令是原子性的，那么答案应该正确。 而实际上，一条add指令可以被看成三条更小的指令：load, ++, store.而这三条指令之间的原子性等没有得到保证，所以出现错误。  x86的解决方法-增加原子性操作  x86架构提供了一些原子性操作来使得软件能够完成锁的实现，比如 lock add(一条原子性的add指令)，xchg(一条原子性的交换内存和变量的值的指令)等。 使用xchg指令可以很简单地实现自旋锁  1 2 3 4 5 6 7 8 9  int table = key; void lock(){ while(1){ int got = xchg(&amp;amp;table,NOTE); if(got == key) break; } } void unlock(){ xchg(&amp;amp;table,key);   RISC-V和Mips的解决办法-提供满足原子性的load和store  LoadReserved/Store-Conditional(LR/SC)  LR: 正常的读取某一个变量，并在相应变量上标记哪个线程所标记。 SC: 储存之前，检查标记是否对应，如果对应则正常存储，否则重做之前的指令。   LR/SC  实际上就是当LR和SC之间的操作都没有被破坏原子性等，自然这些指令就保证了原子性。  数据竞争  并不是加上了锁就能保证多线程的正确运行，比如两个线程用两把锁对同一个变量修改。 实质是 当有两个线程有两个操作访问同一段内存，且这两个操作之间没有原子性的指令(也就是不能保证两个操作执行的顺序)，就会出现数据竞争。 解决办法：对于多线程共享的内存用同一把锁。  </description>
    </item>
    
    <item>
      <title>状态机模型理解程序执行</title>
      <link>https://jarviszly.com/documents/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%8A%B6%E6%80%81%E6%9C%BA%E6%A8%A1%E5%9E%8B%E7%90%86%E8%A7%A3%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C/</link>
      <pubDate>Thu, 14 May 2020 20:30:58 +0800</pubDate>
      
      <guid>https://jarviszly.com/documents/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%8A%B6%E6%80%81%E6%9C%BA%E6%A8%A1%E5%9E%8B%E7%90%86%E8%A7%A3%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C/</guid>
      <description>单线程程序的状态机模型  不同内存和寄存器状态对应了状态机的不同节点。 大部分状态s有唯一的后继状态，存在一些指令，其有后续状态，如rdtsc(获取处理器时间戳)，rdrand(真随机数),syscall(系统调用) 状态机模型是一种理解程序和分析程序的工具  模型的应用 Time travel debugging  程序运行都是从初始结点向后跳转，那么能否从前往后？ 如果能把状态全部记下来是不合理的，但是一条指令只改变很少的寄存器和内存，所以只需要记录两个状态之间的diff就行。 gdb  target record-full 开始记录(此是需要程序已经开始执行) record stop 结束记录 reverse-step(rs)/reverse-stepi(rsi) 向前跳转    Record and Replay  记录程序执行的信息，重现某次程序执行结果。 对于确定性的指令，只需要记录下开始位置和执行了多少条指令。 对于不确定性的指令，则需要记录额外的信息，比如read系统调用，需要记录read的返回值，其读入的具体数据等。  多线程(并发)程序的状态机模型  确定了每一个线程的寄存器状态和共享内存的状态就唯一确定了一个状态机状态，多线程程序的状态机模型本身一个状态的后继状态就是多样的。 因为多线程状态机状态太多了，所以之前的应用需要重新设计。  Peterson算法：实现2个线程的互斥  两个人(P1,P2)分别有一个棋子(F1,F2)并分别可以向卫生间门上的板子上写上对方的名字。 代码如下  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  //假设及其每次原子地执行每一行代码，内存访问立即可见 int f1 = 0, f2 = 0;//棋子 int turn = P1;//厕所上的牌子 void thread_1(){ f1 = 1;//举起自己的棋子  turn = P2;//优先让别人先去  while(f2 &amp;amp;&amp;amp; turn == P2); //对方举了棋子并且还未去  //临界区  f1 = 0;//放下棋子 } void thread_2(){ f2 = 1; turn = P1; while(f1 &amp;amp;&amp;amp; turn == P1); f2 = 0; }    可以枚举出这两个线程执行顺序的所有可能来证明该算法的正确性。  </description>
    </item>
    
    <item>
      <title>并发编程</title>
      <link>https://jarviszly.com/documents/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</link>
      <pubDate>Sun, 10 May 2020 21:48:04 +0800</pubDate>
      
      <guid>https://jarviszly.com/documents/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</guid>
      <description>并发编程 并发和并行  并发(Concurrent): 多个执行流可以不按照一定的顺序执行 并行(Parallel): 多个执行流可以同时执行(多个处理器)  线程共享  线程之间共享所有代码和全局变量。 每个线程拥有自己的堆栈，独享寄存器。  C语言多线程编程之入门  POSIX Threads, man 7 pthreads, 需要gcc -lpthread gcc -I 选项增加include path(效果等价于 #include &amp;ldquo;&amp;quot;)  多线程编程之放弃 放弃原子性  由于 中断/异常 的机制，导致一个线程的代码(指令)不会按照其顺序执行。 例子：山寨支付宝(有钱人的生活就是这般枯燥无味)  1 2 3 4 5 6 7 8 9  int money bool pay(int cost){ if(money &amp;gt;= cost){ money -= cost; return true; } else return false; }   放弃顺序性  由于 编译器的优化 指令的顺序可能和程序的顺序不一致。 例子：不同优化等级的for循环累加  1 2 3 4  #define n 100000int sum = 0; for(int i = 0; i &amp;lt; n; ++i) sum++;    可以使用objdump -d 查看不同优化等级下的汇编代码。  放弃可见性  由于 CPU 的加速，导致指令不一定按照其显示的顺序执行。 例子：两个线程分别对x，y赋值并打印  1 2 3 4 5 6 7 8 9 10 11  int x = 0, y = 0; void thread_1(){ [1] x = 1; [2] printf(&amp;#34;y = %d\n&amp;#34;,y); } void thread_2(){ [3] y = 1; [4] printf(&amp;#34;x = %d\n&amp;#34;,x); }      x y 概率 调度顺序     0 0 0.</description>
    </item>
    
  </channel>
</rss>
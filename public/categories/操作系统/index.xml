<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>操作系统 on 浙语临湖</title>
    <link>https://jarviszly.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</link>
    <description>Recent content in 操作系统 on 浙语临湖</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
    <lastBuildDate>Sat, 16 May 2020 23:23:18 +0800</lastBuildDate>
    
	<atom:link href="https://jarviszly.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>线程的互斥</title>
      <link>https://jarviszly.com/documents/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BA%92%E6%96%A5/</link>
      <pubDate>Sat, 16 May 2020 23:23:18 +0800</pubDate>
      
      <guid>https://jarviszly.com/documents/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BA%92%E6%96%A5/</guid>
      <description>在现代处理器上Peterson算法的问题  Peterson算法中的，x = 1; turn = T2; 在处理器上会变成指令store(x, 1) store(turn, T2).而因为store指令都比较耗费时间，所以在现代处理器的优化下，处理器会指令后面的指令从而导致两个线程都进入临界区。 很大的问题在于在计算机世界中，我们无法同时&amp;quot;看&amp;quot;和&amp;quot;做&amp;quot;即不能同时load 和 store.  共享内存带来更多的问题  由于不能同时load和store所以当线程共享内存时，会引发其他问题，比如多线程求sum. 四个线程求和放入同一个变量，加法对应的指令只有一条add，如果按照状态机的假设，每次只执行一条指令且指令是原子性的，那么答案应该正确。 而实际上，一条add指令可以被看成三条更小的指令：load, ++, store.而这三条指令之间的原子性等没有得到保证，所以出现错误。  x86的解决方法-增加原子性操作  x86架构提供了一些原子性操作来使得软件能够完成锁的实现，比如 lock add(一条原子性的add指令)，xchg(一条原子性的交换内存和变量的值的指令)等。 使用xchg指令可以很简单地实现自旋锁  1 2 3 4 5 6 7 8 9  int table = key; void lock(){ while(1){ int got = xchg(&amp;amp;table,NOTE); if(got == key) break; } } void unlock(){ xchg(&amp;amp;table,key);   RISC-V和Mips的解决办法-提供满足原子性的load和store  LoadReserved/Store-Conditional(LR/SC)  LR: 正常的读取某一个变量，并在相应变量上标记哪个线程所标记。 SC: 储存之前，检查标记是否对应，如果对应则正常存储，否则重做之前的指令。   LR/SC  实际上就是当LR和SC之间的操作都没有被破坏原子性等，自然这些指令就保证了原子性。  数据竞争  并不是加上了锁就能保证多线程的正确运行，比如两个线程用两把锁对同一个变量修改。 实质是 当有两个线程有两个操作访问同一段内存，且这两个操作之间没有原子性的指令(也就是不能保证两个操作执行的顺序)，就会出现数据竞争。 解决办法：对于多线程共享的内存用同一把锁。  </description>
    </item>
    
    <item>
      <title>状态机模型理解程序执行</title>
      <link>https://jarviszly.com/documents/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%8A%B6%E6%80%81%E6%9C%BA%E6%A8%A1%E5%9E%8B%E7%90%86%E8%A7%A3%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C/</link>
      <pubDate>Thu, 14 May 2020 20:30:58 +0800</pubDate>
      
      <guid>https://jarviszly.com/documents/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%8A%B6%E6%80%81%E6%9C%BA%E6%A8%A1%E5%9E%8B%E7%90%86%E8%A7%A3%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C/</guid>
      <description>单线程程序的状态机模型  不同内存和寄存器状态对应了状态机的不同节点。 大部分状态s有唯一的后继状态，存在一些指令，其有后续状态，如rdtsc(获取处理器时间戳)，rdrand(真随机数),syscall(系统调用) 状态机模型是一种理解程序和分析程序的工具  模型的应用 Time travel debugging  程序运行都是从初始结点向后跳转，那么能否从前往后？ 如果能把状态全部记下来是不合理的，但是一条指令只改变很少的寄存器和内存，所以只需要记录两个状态之间的diff就行。 gdb  target record-full 开始记录(此是需要程序已经开始执行) record stop 结束记录 reverse-step(rs)/reverse-stepi(rsi) 向前跳转    Record and Replay  记录程序执行的信息，重现某次程序执行结果。 对于确定性的指令，只需要记录下开始位置和执行了多少条指令。 对于不确定性的指令，则需要记录额外的信息，比如read系统调用，需要记录read的返回值，其读入的具体数据等。  多线程(并发)程序的状态机模型  确定了每一个线程的寄存器状态和共享内存的状态就唯一确定了一个状态机状态，多线程程序的状态机模型本身一个状态的后继状态就是多样的。 因为多线程状态机状态太多了，所以之前的应用需要重新设计。  Peterson算法：实现2个线程的互斥  两个人(P1,P2)分别有一个棋子(F1,F2)并分别可以向卫生间门上的板子上写上对方的名字。 代码如下  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  //假设及其每次原子地执行每一行代码，内存访问立即可见 int f1 = 0, f2 = 0;//棋子 int turn = P1;//厕所上的牌子 void thread_1(){ f1 = 1;//举起自己的棋子  turn = P2;//优先让别人先去  while(f2 &amp;amp;&amp;amp; turn == P2); //对方举了棋子并且还未去  //临界区  f1 = 0;//放下棋子 } void thread_2(){ f2 = 1; turn = P1; while(f1 &amp;amp;&amp;amp; turn == P1); f2 = 0; }    可以枚举出这两个线程执行顺序的所有可能来证明该算法的正确性。  </description>
    </item>
    
    <item>
      <title>并发编程</title>
      <link>https://jarviszly.com/documents/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</link>
      <pubDate>Sun, 10 May 2020 21:48:04 +0800</pubDate>
      
      <guid>https://jarviszly.com/documents/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</guid>
      <description>并发编程 并发和并行  并发(Concurrent): 多个执行流可以不按照一定的顺序执行 并行(Parallel): 多个执行流可以同时执行(多个处理器)  线程共享  线程之间共享所有代码和全局变量。 每个线程拥有自己的堆栈，独享寄存器。  C语言多线程编程之入门  POSIX Threads, man 7 pthreads, 需要gcc -lpthread gcc -I 选项增加include path(效果等价于 #include &amp;ldquo;&amp;quot;)  多线程编程之放弃 放弃原子性  由于 中断/异常 的机制，导致一个线程的代码(指令)不会按照其顺序执行。 例子：山寨支付宝(有钱人的生活就是这般枯燥无味)  1 2 3 4 5 6 7 8 9  int money bool pay(int cost){ if(money &amp;gt;= cost){ money -= cost; return true; } else return false; }   放弃顺序性  由于 编译器的优化 指令的顺序可能和程序的顺序不一致。 例子：不同优化等级的for循环累加  1 2 3 4  #define n 100000int sum = 0; for(int i = 0; i &amp;lt; n; ++i) sum++;    可以使用objdump -d 查看不同优化等级下的汇编代码。  放弃可见性  由于 CPU 的加速，导致指令不一定按照其显示的顺序执行。 例子：两个线程分别对x，y赋值并打印  1 2 3 4 5 6 7 8 9 10 11  int x = 0, y = 0; void thread_1(){ [1] x = 1; [2] printf(&amp;#34;y = %d\n&amp;#34;,y); } void thread_2(){ [3] y = 1; [4] printf(&amp;#34;x = %d\n&amp;#34;,x); }      x y 概率 调度顺序     0 0 0.</description>
    </item>
    
  </channel>
</rss>